load robot .
load collectionPoint .
load time-inf .
load obstacle . 

omod TIMED-FARM is
    protecting ROBOT .
    protecting CPOINT .
    protecting TIME-INF .
    protecting MAP .
    protecting GROWING-LOC .
    protecting OBSTACLE .

    sort ClockedConfiguration .
    class Context | obstacles : Configuration .

    op  _@_ : Configuration Time -> ClockedConfiguration [ctor] .
    op minusToZero : Int Int -> Nat .
    op minIgnoreZero : NatInf NatInf -> NatInf [assoc comm] .
    op maxTimeAdvance : Configuration Configuration -> Time .
    op timeEffect : Object Time Object -> Object .

    vars CONF CONF2 CONF3 : Configuration .
    var T : Time .
    var O : Object .
    vars S S' : String .
    vars X X2 Y Y2 X3 Y3 SP : Int .
    vars N N' N2 N2' N3 N4 : Nat .
    var LL : List-Location .
    vars I I2 : Int .
    vars NI NI2 : NatInf .

    eq minusToZero(I, I2) = if (I - I2) < 0 then 0 else I - I2 fi .
    eq minIgnoreZero(0,0) = natInf .
    eq minIgnoreZero(0, NI) = NI .
    eq minIgnoreZero(NI, NI2) = min(NI, NI2) .

    eq maxTimeAdvance(none) = natInf .
    eq maxTimeAdvance(< S : Map | > CONF) = maxTimeAdvance(CONF) .
    eq maxTimeAdvance(< S : Context | >) = natInf .

    ***maxTimeAdvance for growing-loc is the amount of time until one of the timers reaches 0.
    ***If the timer has reached 0, but the state hasn't changed yet, maxTimeAdvance is 0, so that the state can be updated.
    ***maxTimeAdvance of growing-loc does not depend on the rest of the environment.
    eq maxTimeAdvance(< S : Growing-loc | waterTimer : 0, waterLevel : good >, CONF) = 0 .
    eq maxTimeAdvance(< S : Growing-loc | fertilizerTimer : 0, fertilizerLevel : good >, CONF) = 0 .
    eq maxTimeAdvance(< S : Growing-loc | growTimer : 0, growingState : growing >, CONF) = 0 .
    eq maxTimeAdvance(< S : Growing-loc | waterTimer : N, fertilizerTimer : N', growTimer : N2 >, CONF) = minIgnoreZero(N2,minIgnoreZero(N,N')) .

    ***maxTimeAdvance on robots returns a natural number based on how many times the robot can move until it reaches the next intersection or obstacle in its path
    ***Ignore robots that are finished with their path.
    ***If there is an obstacle in the way then check if the robot would collide if it and update maxTimeAdvance accordingly.
    eq maxTimeAdvance(< S : Robot | remainingPath : nil >, CONF) = inf .
    eq maxTimeAdvance(< S : Robot | location : (X, Y), speed : SP, remainingPath : (X2, Y2) LL >, < S' : Context | obstacles : CONF >)
    = 
    if obstacleInWay((X,Y), (X2,Y2), CONF) =/= none then
        distance((X,Y), getLocation(obstacleInWay((X,Y), (X2,Y2), CONF))) / SP
    else
        distance((X,Y), (X2,Y2)) / SP
    fi .

    ***call maxTimeAdvance on every object in the configuration.
    eq maxTimeAdvance(none, CONF) = natInf .
    ceq maxTimeAdvance(CONF CONF2, CONF3) = min(maxTimeAdvance(CONF, CONF3), maxTimeAdvance(CONF2, CONF3)) if CONF =/= none and CONF2 =/= none .


    eq timeEffect(none, N) = none .
    ***call timeEffect on every object in the configuration.
    eq timeEffect(< S : Context | >, N) = < S : Context | > .
    eq timeEffect(< S : Map | > CONF, N) = < S : Map | > timeEffect(CONF, N) .

    ***If a robot would move "into" an obstacle, it crashes instead.
    eq timeEffect(< S : Robot | remainingPath : nil > CONF, N) = < S : Robot | > timeEffect(CONF, N) .
    eq timeEffect(< S : Robot | state : crashed > CONF, N) = < S : Robot | > timeEffect(CONF,N) .
    eq timeEffect(< S : Robot | location : (X,Y), direction : north, speed : SP, remainingPath : {(X,Y2) (X3, Y3)} P, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X,Y + (SP * N)) in CONF2 then
            < S : Robot | location : (X, (Y - 1) + (SP * N)), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if Y + (SP * N) > Y2
                then
                    < S : Robot | location : (X , Y2) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X, Y + (N * SP)) >  timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi 
        fi .
    eq timeEffect(< S : Robot | location : (X,Y), direction : east, speed : SP, remainingPath : {(X2,Y) (X3, Y3)} P, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X + (SP * N), Y) in CONF2 then
            < S : Robot | location : ((X - 1) + (SP * N), Y), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if X + (SP * N) > X2
                then
                    < S : Robot | location : (X2 , Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X + (SP * N), Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi
        fi .
    eq timeEffect(< S : Robot | location : (X , Y), direction : south, speed : SP, remainingPath : {(X,Y2) (X3, Y3)} P, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X, Y - (SP * N)) in CONF then
            < S : Robot | location : (X, (Y + 1) - (SP * N)), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if Y - (SP * N) < Y2
                then
                    < S : Robot | location : (X, Y2) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X, Y - (SP * N)) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi
        fi .
    eq timeEffect(< S : Robot | location : (X , Y), direction : west, speed : SP, remainingPath : {(X2,Y) (X3, Y3)} P, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X - (SP * N), Y) in CONF then
            < S : Robot | location : ((X + 1) - (SP * N), Y), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if X - (SP * N) < X2
                then
                    < S : Robot | location : (X2, Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X - (SP * N), Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi
        fi .

    eq timeEffect(< S : Growing-loc | waterLevel : low, fertilizerLevel : low >, N, CONF) = < S : Growing-loc | > .
    eq timeEffect(< S : Growing-loc | waterLevel : low, fertilizerTimer : N >, N2, CONF) = < S : Growing-loc | fertilizerTimer : minusToZero(N,N2) > .
    eq timeEffect(< S : Growing-loc | fertilizerLevel : low, waterTimer : N >, N2, CONF) = < S : Growing-loc | waterTimer : minusToZero(N,N2) > . 
    eq timeEffect(< S : Growing-loc | waterTimer : N, fertilizerTimer : N', growTimer : N2, growingState : harvest >, N2', CONF) =
        < S : Growing-loc | waterTimer : minusToZero(N,N2'), fertilizerTimer : minusToZero(N', N2'), growTimer : minusToZero(N2, N2') > .
    eq timeEffect(< S : Growing-loc | waterTimer : N, fertilizerTimer : N', growTimer : N2 >, N2', CONF) =
        < S : Growing-loc | waterTimer : minusToZero(N,N2'), fertilizerTimer : minusToZero(N', N2'), growTimer : minusToZero(N2, N2') > .

    crl [timeEffect] :
        CONF @ T
        =>
        timeEffect(CONF, maxTimeAdvance(CONF)) @ (T + maxTimeAdvance(CONF))
        if maxTimeAdvance(CONF) > 0 .
endom