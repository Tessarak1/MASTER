load robot .
load time-inf .
load obstacle . 
load buildings .
load listRat .
omod TIMED-FARM is
    protecting ROBOT .
    protecting TIME-INF .
    protecting MAP .
    protecting FIELD .
    protecting OBSTACLE .
    protecting BUILDINGS .
    protecting LIST-RAT .

    ***filter based on workers/transporters/fields here? Makes most sense to facilitate multicast instead of broadcast.
    sort ClockedConfiguration .

    op  _@_ : Configuration Time -> ClockedConfiguration [ctor] .
    op $maxTimeAdvanceRobot : Oid Configuration -> TimeInf .
    op $maxTimeAdvanceField : Object -> TimeInf .
    op maxTimeAdvance : Configuration -> TimeInf .

    op $destinationTimeAdvance : Object Configuration -> Time .
    op quadraticTimeAdvance : Rat Rat Rat Time -> Time .
    op $quadraticSolveAdvance : Object Object -> Time .
    op $coefficientA : Rat Rat -> Rat .
    op $coefficientB : Rat Rat Rat Rat -> Rat .
    op $coefficientC : Rat Rat Rat -> Rat .

    op timeEffect : Configuration Time -> Configuration .
    ops $timeEffectRobot $timeEffectField : Object Time -> Object .

    op $calculateAdvance : Object Object Rat -> Time .
    op calculateAdvance : Object Object -> Time .
    op collision : Configuration Object -> Configuration .
    op handleCollisions : Configuration -> Configuration .
    op updateLocation : Object -> Object .
    op unavoidableCrash : Object Object -> Bool .

    vars CONF CONF2 CONF3 : Configuration .
    var OBS : Configuration .
    var AUS : AuctionSet .
    vars TIME TIME2 : Time .
    var RS : RoadSet .
    vars TR TR2 TR3 TR4 : Timer .
    var O : Object .
    vars OID OID2 OID3 : String .
    vars X X2 Y Y2 X3 Y3 : Rat .
    vars SP SP2 : Rat .
    vars DIST DIST2 : Rat .
    vars T T2 : Rat .
    vars N N' N2 N3 N4 : Nat .
    vars L L2 : Level .
    vars LL LL2 : List-Location .
    vars I I2 : Int .
    vars D D2 : Direction .
    var STATE : State .
    vars R R2 R3 : Rat .
    var GS : GrowingState .
    var REPS : RepresentationSet .
    var C : Cargo .
    var FUNC : FunctioningState .
    var INC : IncapacitatedState .
    var MSG : Msg .
    var MC : MsgContent .
    vars WS WS2 : WorkState .
    var TID : Tid .
    var TT : TaskType .
    var WT : WorkerTask .
    var TPT : TransporterTask .
    var YIS : YieldInformationSet .
    var WI : WaitingInformation .
    var BIS : BaseInformationSet .

    eq $coefficientA(SP, SP2) = (SP ^ 2) + (SP2 ^ 2) .
    eq $coefficientB(SP, DIST, SP2, DIST2) = -2 * ((SP * DIST) + (SP2 * DIST2)) .
    eq $coefficientC(DIST, DIST2, T) = (DIST ^ 2) + (DIST2 ^ 2 ) + (-1 * (T ^ 2)) .

    eq quadraticTimeAdvance(R, R2, R3, T) =
        if quadraticFormula(R,R2, R3) == nil
        then
            T
        else
            quadraticFormula(R, R2, R3) 
        fi .

    ***Calculates the time until two robots that are moving on different axes towards the same intersection detect each other.
    eq $quadraticSolveAdvance(< OID : Robot | location : (X,Y), speed : SP, remainingPath : (X2,Y2) LL, detectionRange : T >, < OID2 : Robot | location : (X3,Y3), speed : SP2, remainingPath : (X2,Y2) LL2, detectionRange : T2 >) =
        if distance((X,Y), (X3,Y3)) > max(T, T2)
        then
            quadraticTimeAdvance(
                $coefficientA(SP, SP2),
                $coefficientB(SP, distance((X,Y), (X2,Y2)), SP2, distance((X3,Y3), (X2,Y2))),
                $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), max(T,T2)),
                distance((X,Y), (X2,Y2)) / SP
            )
        else
            if distance((X,Y), (X3,Y3)) > min(T, T2)
            then
                quadraticTimeAdvance(
                    $coefficientA(SP, SP2),
                    $coefficientB(SP, distance((X,Y), (X2,Y2)), SP2, distance((X3,Y3), (X2,Y2))),
                    $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), min(T,T2)),
                    distance((X,Y), (X2,Y2)) / SP
                )   
            else
                distance((X,Y), (X2,Y2)) / SP
            fi
        fi .
    

    eq updateLocation(< OID : Robot | location : (X, Y), direction : north >) = < OID : Robot | location : (X, Y - ROBOT-SIZE) > .
    eq updateLocation(< OID : Robot | location : (X, Y), direction : east >) = < OID : Robot | location : (X - ROBOT-SIZE, Y) > .
    eq updateLocation(< OID : Robot | location : (X, Y), direction : south >) = < OID : Robot | location : (X, Y + ROBOT-SIZE) > .
    eq updateLocation(< OID : Robot | location : (X, Y), direction : west >) = < OID : Robot | location : (X + ROBOT-SIZE, Y) > .

    eq collision(< OID : Robot | location : (X, Y) > < OID2 : Obstacle | >, < OID3 : Map | >) =  updateLocation(< OID : Robot | speed : 0, state : crashed >) < OID2 : Obstacle | > .
    ceq collision(< OID : Robot | speed : SP > < OID2 : Robot | speed : SP2 >, < OID3 : Map | roads : RS >) = 
        updateLocation(< OID : Robot | state : crashed, speed : 0 >) < OID2 : Robot | speed : 0, state : crashed >
        if outsideMap(getLocation(updateLocation(< OID : Robot | >)), RS) == false .

    eq handleCollisions(< OID : Robot | location : (X, Y) > < OID2 : PhysicalObj | location : (X, Y) >  < OID3 : Map | > CONF) = collision(< OID : Robot | > < OID2 : PhysicalObj | >, < OID3 : Map | >) handleCollisions(< OID3 : Map | > CONF) .
    eq handleCollisions(CONF) = CONF [owise] .

    eq unavoidableCrash(< OID : Robot | >, none) = false .
    eq unavoidableCrash(< OID : Robot | speed : 0 >, O) = false .
    ceq unavoidableCrash(< OID : Robot | state : moving, location : (X, Y), direction : D, speed : SP >, < OID2 : Robot | state : moving, location : (X2, Y2), direction : D2, speed : SP2 >) = 
        if distance((X, Y), (X2, Y2)) <= stoppingDistance(< OID : Robot | >) + stoppingDistance(< OID2 : Robot | >) then
            true
        else
            false
        fi
    if oppositeDirections(D, D2) .
    eq unavoidableCrash(< OID : Robot | location : (X, Y) >, < OID2 : PhysicalObj | location : (X2, Y2) >) = 
        if distance((X, Y), (X2, Y2)) <= stoppingDistance(< OID : Robot | >)
        then
            true
        else
            false
        fi .
    ceq unavoidableCrash(< OID : Robot | state : moving, location : (X,Y), direction : D, remainingPath : (X2,Y2) LL, speed : SP >, < OID2 : Robot | state : moving, location : (X3,Y3), direction : D2, remainingPath : (X2,Y2) LL2, speed : SP2 >) =
        if (distance((X,Y), (X2,Y2)) / SP) == distance((X3,Y3), (X2,Y2))
        then
            true
        else
            false
        fi
        if differentAxes(D, D2) .

    eq $calculateAdvance(< OID : Robot | location : (X,Y), detectionRange : T >, < OID2 : Robot | location : (X2,Y2), detectionRange : T2 >, SP) =
        if unavoidableCrash(< OID : Robot | >, < OID2 : Robot | >)
        then
            distance((X,Y), (X2,Y2)) / SP
        else
            if distance((X,Y), (X2,Y2)) > max(T, T2)
            then
                (distance((X,Y), (X2,Y2)) - max(T,T2)) / SP
            else
                if distance((X,Y), (X2,Y2)) > min(T,T2)
                then
                    (distance((X,Y), (X2,Y2)) - min(T,T2)) / SP
                else
                    if distance((X,Y), (X2,Y2)) > FINAL-RANGE
                    then
                        (distance((X,Y), (X2,Y2)) - FINAL-RANGE) / SP
                    else
                        distance((X,Y), (X2,Y2)) / SP
                    fi
                fi
            fi
        fi .
    
    ***If nothing is in the way then time until next location is reached.
    eq calculateAdvance(< OID : Robot | state : moving, location : (X,Y), remainingPath : (X2,Y2) LL, speed : SP >, none) = distance((X,Y), (X2,Y2)) / SP .
    ***If a robot is behind another in the same direction check time until detection happens.
    eq calculateAdvance(< OID : Robot | speed : SP, direction : D >, < OID2 : Robot | state : moving, speed : SP2, direction : D >) = 
        if SP2 >= SP then
            ratInf  
        else
            $calculateAdvance(< OID : Robot | >, < OID2 : Robot | >, SP - SP2)
        fi .
    ***Check detection if two robots are moving towards one another
    ceq calculateAdvance(< OID : Robot | state : moving, speed : SP, direction : D >, < OID2 : Robot | state : moving, speed : SP2, direction : D2 >) = 
        $calculateAdvance(< OID : Robot | >, < OID2 : Robot | >, SP + SP2)
        if oppositeDirections(D,D2) .
    ***If the second robot is unmoving, check time until detection happens based on first robot's speed.
    ceq calculateAdvance(< OID : Robot | state : moving, speed : SP >, < OID2 : Robot | state : STATE >) =
        $calculateAdvance(< OID : Robot | >, < OID2 : Robot | >, SP)
        if STATE =/= moving .
    ***Moving towards the same point as another robot from different axes.
    ceq calculateAdvance(< OID : Robot | state : moving, remainingPath : (X,Y) LL, direction : D >, < OID2 : Robot | state : moving, direction : D2 >) =
        $quadraticSolveAdvance(< OID : Robot | >, < OID2 : Robot | >)
        if differentAxes(D, D2) and headedTowards(< OID2 : Robot | >, (X,Y)) .
    
    ***TODO: add a lower limit here
    eq calculateAdvance(< OID : Robot | state : moving, location : (X, Y), speed : SP, detectionRange : T >, < OID2 : Obstacle | location : (X2,Y2) >) = 
        if unavoidableCrash(< OID : Robot | >, < OID2 : Obstacle | >) then
            distance((X, Y), (X2,Y2)) / SP
        else
            if (distance((X, Y), (X2,Y2)) > T) then
                (distance((X, Y), (X2,Y2)) - T) / SP
            else
                if distance((X,Y), (X2,Y2)) > FINAL-RANGE
                then
                    (distance((X,Y), (X2,Y2)) - FINAL-RANGE) / SP
                else
                    distance((X,Y), (X2,Y2)) / SP
                fi
            fi 
        fi .



    eq $destinationTimeAdvance(< OID : Robot | location : (X,Y), remainingPath : (X2,Y2) LL, speed : SP >, none) = distance((X,Y), (X2,Y2)) / SP .
    eq $destinationTimeAdvance(< OID : Robot | >, < OID2 : Robot | > CONF) = min(calculateAdvance(< OID : Robot | >, < OID2 : Robot | >), $destinationTimeAdvance(< OID : Robot | >, CONF)) .


    ***Needs to start working on a field
    ceq $maxTimeAdvanceRobot(OID, < OID : Robot | location : (X,Y), curTask : [OID2, TT], workState : noWork > < OID2 : Field | location : (X,Y) > CONF) = 0 if canCompleteNow(< OID : Robot | >, [OID2, TT]) .
    ***Needs to finish working on a field.
    eq $maxTimeAdvanceRobot(OID, < OID : Worker | location : (X,Y), state : FUNC, remainingPath : nil, workState : [OID2, WT], cargoLevel : full > < OID2 : Field | location : (X,Y) > CONF) = 0 .
    eq $maxTimeAdvanceRobot(OID, < OID : Transporter | location : (X,Y), state : FUNC, remainingPath : nil, workState : [OID2, TPT], cargoLevel : empty > < OID2 : Field | location : (X,Y) > CONF) = 0 .
    ***Don't advance time if a robot needs to parse through detections
    ceq $maxTimeAdvanceRobot(OID, < OID : Robot | detected : REPS > CONF) = 0 if REPS =/= none .    
    ***Needs to potentially change directions
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : moving, location : (X,Y), remainingPath : (X,Y) LL > CONF) = 0 .
    ***Needs to stop negotiating
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : negotiating, negotiations : none > CONF) = 0 .
    ***Needs to transition to planningPath
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : idle, remainingPath : nil, yieldStatus : noYieldInformation, curTask : TID > CONF) = 0 .
    ***Needs to stop waiting
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : waiting, waitingStatus : noWaitingInformation > CONF) = 0 .
    ***Allow robot to start resupplying if needed
    ceq $maxTimeAdvanceRobot(OID, < OID : Robot | location : (X,Y), state : FUNC, curTask : TID > < OID2 : ResupplyStation | location : (X,Y) > CONF) = 0 if needsResupply(< OID : Robot | >, TID) and (FUNC =/= resupplying) .
    ***finish resupply.
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | location : (X,Y), state : resupplying, workState : [OID2, resupplyTask, 0] >  < OID2 : ResupplyStation | location : (X,Y) > CONF) = 0 .
    ***Need to start unloading
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | location : (X,Y), state : FUNC, cargoLevel : full, workState : noWork > < OID2 : CollectionStation | location : (X,Y) > CONF) = 0 .
    ***Need to finish unloading
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | location : (X,Y), state : unloading, cargoLevel : full, workState : [OID2, unloadTask, 0] > < OID2 : CollectionStation | location : (X,Y) > CONF) = 0 .
    ***Needs to start replanning path.
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : planningPath > CONF) = 0 .
    ***Needs to start movement
    ceq $maxTimeAdvanceRobot(OID, < OID : Robot | state : idle, remainingPath : LL, detected : none > CONF) = 0 if LL =/= nil .
    ***Not relevant if incapacitated, negotiating, idle or waiting
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : INC, detected : none > CONF) = ratInf .
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : negotiating, detected : none > CONF) = ratInf .
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : idle, remainingPath : nil, detected : none > CONF) = ratInf .
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : waiting, waitingStatus : [BIS | TR | TR2] > CONF) = ratInf .
    ***time until timedWork is completed.
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : FUNC, workState : [OID2, TT, TIME], detected : none > CONF) = TIME .
    ***If it is moving uninterrupted towards an intersection then check until it may detect other robots that are closest to that intersection
    ceq $maxTimeAdvanceRobot(OID, < OID : Robot | state : moving, location : (X,Y), remainingPath : (X2,Y2) LL > CONF) = 
        $destinationTimeAdvance(< OID : Robot | >, remove(OID, closest((X2,Y2), none, sameDestination((X2,Y2), getRobots(CONF)))))
        if (objectInWay((X,Y), (X2,Y2), CONF) == none) .
    ***The previous equation wont apply if there is a robot located at the intersection the robot is moving away from it.
    ***This equation ensures that destinationTimeAdvance is still applied in such a scenario.
    ***The condition checks if the first object in the way is a robot 
    ceq $maxTimeAdvanceRobot(OID, < OID : Robot | state : moving, location : (X,Y), remainingPath : (X2,Y2) LL, direction : D > < OID2 : Robot | state : moving, location : (X2,Y2), direction : D2 > CONF) =
        $destinationTimeAdvance(< OID : Robot | >, remove(OID, closest((X2,Y2), none, getRobots(CONF))))
        if (getOid(objectInWay((X,Y), (X2,Y2), < OID2 : Robot | state : moving, location : (X2,Y2), direction : D2 > CONF)) == OID2) and not oppositeDirections(D, D2) .
    ***If there is an obstacle or robot in the way, return time until detection happens.
    eq $maxTimeAdvanceRobot(OID, < OID : Robot | state : moving, location : (X, Y), speed : SP, remainingPath : (X2, Y2) LL, detected : none > CONF)
    =
    calculateAdvance(< OID : Robot | >, objectInWay((X, Y), (X2,Y2), CONF)) [owise] .

    ceq $maxTimeAdvanceField(< OID : Field | >) = 0 if needToStartAuction(< OID : Field | >) .
    eq $maxTimeAdvanceField(< OID : Field | >) = fieldTimer(< OID : Field | >) [owise] .

    eq maxTimeAdvance(< OID : Robot | handledTime : false, auctions : AUS, yieldStatus : YIS, waitingStatus : WI > CONF) =
        min(minTimer(getAuctionTimers(AUS) getYieldTimers(YIS) getWaitingTimer(WI)),
        min($maxTimeAdvanceRobot(OID, < OID : Robot | > CONF),
        maxTimeAdvance(< OID : Robot | handledTime : true > CONF))) .
    eq maxTimeAdvance(< OID : Field | handledTime : false, auctions : AUS > CONF) = min(minTimeToClose(AUS), min($maxTimeAdvanceField(< OID : Field | >), maxTimeAdvance(< OID : Field | handledTime : true > CONF))) .
    ***time until the message becomes active.
    eq maxTimeAdvance(dly(MSG, TIME) CONF) = min(TIME, maxTimeAdvance(CONF)).
    eq maxTimeAdvance(CONF) = ratInf [owise] .

    ***Robot moves towards next location
    eq $timeEffectRobot(< OID : Robot | state : moving, location : (X, Y), direction : north, speed : SP, remainingPath : (X2,Y2) LL >, TIME) = < OID : Robot | location : (X, Y + (SP * TIME)) > .
    eq $timeEffectRobot(< OID : Robot | state : moving, location : (X, Y), direction : east, speed : SP, remainingPath : (X2,Y2) LL >, TIME) = < OID : Robot | location : (X + (SP * TIME), Y) > .
    eq $timeEffectRobot(< OID : Robot | state : moving, location : (X, Y), direction : south, speed : SP, remainingPath : (X2,Y2) LL >, TIME) = < OID : Robot | location : (X, Y - (SP * TIME)) > .
    eq $timeEffectRobot(< OID : Robot | state : moving, location : (X, Y), direction : west, speed : SP, remainingPath : (X2,Y2) LL >, TIME) = < OID : Robot | location : (X - (SP * TIME), Y) > .
    ***Can be ignored if the robot is incapacitated or idle.
    ceq $timeEffectRobot(< OID : Robot | state : STATE >, TIME) = < OID : Robot | > if STATE =/= moving .

    eq timeEffect(< OID : Robot | > CONF, TIME) = $timeEffectRobot(decreaseTimers(< OID : Robot | >, TIME), TIME) timeEffect(CONF, TIME) .
    eq timeEffect(< OID : Field | > CONF, TIME) = decreaseTimers(< OID : Field | >, TIME) timeEffect(CONF, TIME) .
    eq timeEffect(dly(MSG, TIME) CONF, TIME2) = dly(MSG, TIME monus TIME2) timeEffect(CONF, TIME) .
    eq timeEffect(CONF, TIME) = CONF [owise] .


    crl [timeEffect] :
        CONF @ TIME
        =>
        detect(handleCollisions(timeEffect(CONF, maxTimeAdvance(CONF)))) @ (TIME + maxTimeAdvance(CONF))
        if maxTimeAdvance(CONF) > 0 and maxTimeAdvance(CONF) < ratInf .
endom