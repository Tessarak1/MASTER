load robot .
load collectionPoint .
load time-inf .
load obstacle . 

omod TIMED-FARM is
    protecting ROBOT .
    protecting CPOINT .
    protecting TIME-INF .
    protecting MAP .
    protecting GROWING-LOC .
    protecting OBSTACLE .

    sort ClockedConfiguration .
    class Context | obstacles : Configuration .

    op  _@_ : Configuration Time -> ClockedConfiguration [ctor] .
    op minusToZero : Int Int -> Nat .
    op minIgnoreZero : NatInf NatInf -> NatInf [assoc comm] .
    op maxTimeAdvance : Configuration -> Time .
    op timeEffect : Configuration Time -> Configuration .

    vars CONF CONF2 CONF3 : Configuration .
    var T : Time .
    var O : Object .
    vars S S' : String .
    vars X X2 Y Y2 SP : Int .
    vars N N' N2 N2' N3 N4 : Nat .
    var LL : List-Location .
    vars I I2 : Int .
    vars NI NI2 : NatInf .

    eq minusToZero(I, I2) = if (I - I2) < 0 then 0 else I - I2 fi .
    eq minIgnoreZero(0,0) = natInf .
    eq minIgnoreZero(0, NI) = NI .
    eq minIgnoreZero(NI, NI2) = min(NI, NI2) .

    eq maxTimeAdvance(none) = natInf .
    eq maxTimeAdvance(< S : Map | > CONF) = maxTimeAdvance(CONF) .
    eq maxTimeAdvance(< S : Context | >) = natInf .

    ***maxTimeAdvance for growing-loc is the amount of time until one of the timers reaches 0.
    ***If the timer has reached 0, but the state hasn't changed yet, maxTimeAdvance is 0, so that the state can be updated.
    ***maxTimeAdvance of growing-loc does not depend on the rest of the environment.
    eq maxTimeAdvance(< S : Growing-loc | waterTimer : 0, waterLevel : good > CONF) = 0 .
    eq maxTimeAdvance(< S : Growing-loc | fertilizerTimer : 0, fertilizerLevel : good > CONF) = 0 .
    eq maxTimeAdvance(< S : Growing-loc | growTimer : 0, state : growing > CONF) = 0 .
    eq maxTimeAdvance(< S : Growing-loc | waterTimer : N, fertilizerTimer : N2, growTimer : N3 > CONF) = min(minIgnoreZero(N3,minIgnoreZero(N,N2)), maxTimeAdvance(CONF)) .

    ***maxTimeAdvance on robots returns a natural number based on how many times the robot can move until it reaches the next intersection or obstacle in its path
    ***Ignore robots that are finished with their path.
    ***If there is an obstacle in the way then check if the robot would collide if it and update maxTimeAdvance accordingly.
    eq maxTimeAdvance(< S : Robot | remainingPath : nil > CONF) = maxTimeAdvance(CONF) .
    eq maxTimeAdvance(< S : Robot | location : (X, Y), speed : SP, remainingPath : (X2, Y2) LL > < S' : Context | obstacles : CONF > CONF2)
    =
    if obstacleInWay((X,Y), (X2,Y2), CONF) =/= none
    then
        min((distance((X,Y), getLocation(obstacleInWay((X,Y), (X2,Y2), CONF))) / SP), maxTimeAdvance(< S' : Context | obstacles : CONF > CONF2))
    else 
        min((distance((X,Y), (X2,Y2)) / SP), maxTimeAdvance(< S' : Context | obstacles : CONF > CONF2))
    fi .


    eq timeEffect(none, N) = none .
    ***call timeEffect on every object in the configuration.
    eq timeEffect(< S : Context | >, N) = none .
    eq timeEffect(< S : Map | > CONF, N) = < S : Map | > timeEffect(CONF, N) .

    ***If a robot would move "into" an obstacle, it crashes instead.
    eq timeEffect(< S : Robot | remainingPath : nil > CONF, N) = < S : Robot | > timeEffect(CONF, N) .
    eq timeEffect(< S : Robot | state : crashed > CONF, N) = < S : Robot | > timeEffect(CONF,N) .
    eq timeEffect(< S : Robot | location : (X,Y), direction : north, speed : SP, remainingPath : (X,Y2) LL, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X,Y + (SP * N)) in CONF2 then
            < S : Robot | location : (X, (Y - 1) + (SP * N)), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if Y + (SP * N) > Y2
                then
                    < S : Robot | location : (X , Y2) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X, Y + (N * SP)) >  timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi 
        fi .
    eq timeEffect(< S : Robot | location : (X,Y), direction : east, speed : SP, remainingPath : (X2, Y) LL, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X + (SP * N), Y) in CONF2 then
            < S : Robot | location : ((X - 1) + (SP * N), Y), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if X + (SP * N) > X2
                then
                    < S : Robot | location : (X2 , Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X + (SP * N), Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi
        fi .
    eq timeEffect(< S : Robot | location : (X , Y), direction : south, speed : SP, remainingPath : (X,Y2) LL, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X, Y - (SP * N)) in CONF then
            < S : Robot | location : (X, (Y + 1) - (SP * N)), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if Y - (SP * N) < Y2
                then
                    < S : Robot | location : (X, Y2) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X, Y - (SP * N)) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi
        fi .
    eq timeEffect(< S : Robot | location : (X , Y), direction : west, speed : SP, remainingPath : (X2, Y) LL, state : moving > < S' : Context | obstacles : CONF2 > CONF, N)
        =
        if (X - (SP * N), Y) in CONF then
            < S : Robot | location : ((X + 1) - (SP * N), Y), state : crashed > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
        else
            if X - (SP * N) < X2
                then
                    < S : Robot | location : (X2, Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
                else
                    < S : Robot | location : (X - (SP * N), Y) > timeEffect(< S' : Context | obstacles : CONF2 > CONF, N)
            fi
        fi .

    eq timeEffect(< S : Growing-loc | waterLevel : low, fertilizerLevel : low > CONF, N) = < S : Growing-loc | > timeEffect(CONF, N) .
    eq timeEffect(< S : Growing-loc | waterLevel : low, fertilizerTimer : N2 > CONF, N) = < S : Growing-loc | fertilizerTimer : minusToZero(N2,N) > timeEffect(CONF, N) .
    eq timeEffect(< S : Growing-loc | fertilizerLevel : low, waterTimer : N2 > CONF, N) = < S : Growing-loc | waterTimer : minusToZero(N2,N) > timeEffect(CONF, N) . 
    eq timeEffect(< S : Growing-loc | waterTimer : N2, fertilizerTimer : N3, growTimer : N4 > CONF, N) =
        < S : Growing-loc | waterTimer : minusToZero(N2,N), fertilizerTimer : minusToZero(N3, N), growTimer : minusToZero(N4, N) > timeEffect(CONF, N) .

    crl [timeEffect] :
        CONF @ T
        =>
        timeEffect(CONF, maxTimeAdvance(CONF)) @ (T + maxTimeAdvance(CONF))
        if maxTimeAdvance(CONF) > 0 .
endom