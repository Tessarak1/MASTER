load robot .
load time-inf .
load obstacle . 
load listRat .
omod TIMED-FARM is
    protecting ROBOT .
    protecting TIME-INF .
    protecting MAP .
    protecting FIELD .
    protecting OBSTACLE .
    protecting LIST-RAT .

    sort ClockedConfiguration .

    op  _@_ : Configuration Time -> ClockedConfiguration [ctor] .
    op $mteRobot : Oid Configuration -> Time .
    op mte : Configuration -> Time .

    op $destinationTimeAdvance : Object Configuration -> Time .
    op $quadraticSolveAdvance : Object Object -> Time .
    op $coefficientA : Rat Rat -> Rat .
    op $coefficientB : Rat Rat Rat Rat -> Rat .
    op $coefficientC : Rat Rat Rat -> Rat .

    op timeEffect : Object Time -> Object .
    op $calculateAdvance : Object Object Rat -> Time .
    op calculateAdvance : Object Object -> Time .
    op collision : Configuration Object -> Configuration .
    op handleCollisions : Configuration -> Configuration .
    op updateLocation : Object -> Object .
    op detect : Configuration -> Configuration .
    op unavoidableCrash : Object Object -> Bool .
    op _detects_ : Object Object -> Bool .

    vars CONF CONF2 CONF3 : Configuration .
    var OBS : Configuration .
    vars TIME TIME2 : Time .
    var PS : PathSet .
    vars TR TR2 TR3 TR4 : Timer .
    var O : Object .
    vars S S2 S3 : String .
    vars X X2 Y Y2 X3 Y3 : Rat .
    vars SP SP2 : Rat .
    vars DIST DIST2 : Rat .
    vars T T2 : Rat .
    vars N N' N2 N3 N4 : Nat .
    vars L L2 : Level .
    vars LL LL2 : List-Location .
    vars I I2 : Int .
    vars D D2 : Direction .
    var STATE : State .
    vars R R2 : Rat .
    var GS : GrowingState .
    var REP : Representation .
    var C : Cargo .
    var FUNC : FunctioningState .
    var INC : IncapacitatedState .
    var MSG : Msg .
    var MC : MsgContent .
    vars WS WS2 : WorkState .
    var TID : Tid .
    var TT : TaskType .

    eq $coefficientA(SP, SP2) = (SP ^ 2) + (SP2 ^ 2) .
    eq $coefficientB(SP, DIST, SP2, DIST2) = -2 * ((SP * DIST) + (SP2 * DIST2)) .
    eq $coefficientC(DIST, DIST2, T) = (DIST ^ 2) + (DIST2 ^ 2 ) + (-1 * (T ^ 2)) .
    eq $quadraticSolveAdvance(< S : Robot | location : (X,Y), speed : SP, remainingPath : (X2,Y2) LL, detectionRange : T >, < S2 : Robot | location : (X3,Y3), speed : SP2, remainingPath : (X2,Y2) LL2, detectionRange : T2 >) =
        if distance((X,Y), (X3,Y3)) > max(T, T2)
        then
            minElement(
                posOnly(
                    quadraticFormula(
                        $coefficientA(SP, SP2),
                        $coefficientB(SP, distance((X,Y), (X2,Y2)), SP2, distance((X3,Y3), (X2,Y2))),
                        $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), max(T,T2))
                    ) 
                )
            )
 
        else
            if distance((X,Y), (X3,Y3)) > min(T, T2)
            then
                minElement(
                    posOnly(
                        quadraticFormula(
                            $coefficientA(SP, SP2),
                            $coefficientB(SP, distance((X,Y), (X2,Y2)), SP2, distance((X3,Y3), (X2,Y2))),
                            $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), min(T,T2))
                        )   
                    )
                )
            else
                distance((X,Y), (X2,Y2)) / SP
            fi
        fi .
    
    eq < S : Robot | curTask : [S2, TT, N] > detects < S2 : Locatable | > = false .
    eq < S : Robot | location : (X,Y), detected : REP, detectionRange : T > detects < S2 : Locatable | location : (X2,Y2) > = (S2 notIn REP) and ((X2,Y2) inArea(makeArea((X,Y), T))) .
    eq < S : Robot | > detects < S2 : Locatable | > = true [owise] .

    eq updateLocation(< S : Robot | location : (X, Y), direction : north >) = < S : Robot | location : (X, Y - 1) > .
    eq updateLocation(< S : Robot | location : (X, Y), direction : east >) = < S : Robot | location : (X - 1, Y) > .
    eq updateLocation(< S : Robot | location : (X, Y), direction : south >) = < S : Robot | location : (X, Y + 1) > .
    eq updateLocation(< S : Robot | location : (X, Y), direction : west >) = < S : Robot | location : (X + 1, Y) > .

    eq collision(< S : Robot | location : (X, Y) > < S2 : Obstacle | >, < S3 : Map | >) =  updateLocation(< S : Robot | speed : 0, state : crashed >) < S2 : Obstacle | > .
    ceq collision(< S : Robot | speed : SP > < S2 : Robot | speed : SP2 >, < S3 : Map | paths : PS >) = 
        updateLocation(< S : Robot | state : crashed, speed : 0 >) < S2 : Robot | speed : 0, state : crashed >
        if outsideMap(getLocation(updateLocation(< S : Robot | >)), PS) == false .

    eq handleCollisions(< S : Robot | location : (X, Y) > < S2 : PhysicalObj | location : (X, Y) >  < S3 : Map | > CONF) = collision(< S : Robot | > < S2 : PhysicalObj | >, < S3 : Map | >) handleCollisions(CONF) .
    eq handleCollisions(CONF) = CONF [owise] .

    eq unavoidableCrash(< S : Robot | >, none) = false .
    eq unavoidableCrash(< S : Robot | speed : 0 >, O) = false .
    ceq unavoidableCrash(< S : Robot | state : moving, location : (X, Y), direction : D, speed : SP >, < S2 : Robot | state : moving, location : (X2, Y2), direction : D2, speed : SP2 >) = 
        if distance((X, Y), (X2, Y2)) <= stoppingDistance(< S : Robot | >) + stoppingDistance(< S2 : Robot | >) then
            true
        else
            false
        fi
    if opposite(D, D2) .
    eq unavoidableCrash(< S : Robot | location : (X, Y) >, < S2 : PhysicalObj | location : (X2, Y2) >) = 
        if distance((X, Y), (X2, Y2)) <= stoppingDistance(< S : Robot | >)
        then
            true
        else
            false
        fi .
    ceq unavoidableCrash(< S : Robot | state : moving, location : (X,Y), direction : D, remainingPath : (X2,Y2) LL, speed : SP >, < S2 : Robot | state : moving, location : (X3,Y3), direction : D2, remainingPath : (X2,Y2) LL2, speed : SP2 >) =
        if (distance((X,Y), (X2,Y2)) / SP) == distance((X3,Y3), (X2,Y2))
        then
            true
        else
            false
        fi
        if differentAxes(D, D2) .

    eq $calculateAdvance(< S : Robot | location : (X,Y), detectionRange : T >, < S2 : Robot | location : (X2,Y2), detectionRange : T2 >, SP) =
        if unavoidableCrash(< S : Robot | >, < S2 : Robot | >)
        then
            distance((X,Y), (X2,Y2)) / SP
        else
            if distance((X,Y), (X2,Y2)) > max(T, T2)
            then
                (distance((X,Y), (X2,Y2)) - max(T,T2)) / SP
            else
                if distance((X,Y), (X2,Y2)) > min(T,T2)
                then
                    (distance((X,Y), (X2,Y2)) - min(T,T2)) / SP
                else
                    if distance((X,Y), (X2,Y2)) > FINAL-RANGE
                    then
                        (distance((X,Y), (X2,Y2)) - FINAL-RANGE) / SP
                    else
                        distance((X,Y), (X2,Y2)) / SP
                    fi
                fi
            fi
        fi .
    eq calculateAdvance(< S : Robot | location : (X,Y), remainingPath : (X2,Y2) LL, speed : SP >, none) = distance((X,Y), (X2,Y2)) / SP .
    eq calculateAdvance(< S : Robot | speed : SP, direction : D >, < S2 : Robot | state : moving, speed : SP2, direction : D >) = 
        if SP2 >= SP then
            inf
        else
            $calculateAdvance(< S : Robot | >, < S2 : Robot | >, SP - SP2)
        fi .
    ceq calculateAdvance(< S : Robot | speed : SP, direction : D >, < S2 : Robot | state : moving, speed : SP2, direction : D2 >) = 
        $calculateAdvance(< S : Robot | >, < S2 : Robot | >, SP + SP2)
        if opposite(D,D2) .
    ceq calculateAdvance(< S : Robot | speed : SP >, < S2 : Robot | state : STATE >) =
        $calculateAdvance(< S : Robot | >, < S2 : Robot | >, SP)
        if STATE =/= moving .
    ceq calculateAdvance(< S : Robot | direction : D >, < S2 : Robot | state : moving, direction : D2 >) =
        $quadraticSolveAdvance(< S : Robot | >, < S2 : Robot | >)
        if differentAxes(D, D2) .
    eq calculateAdvance(< S : Robot | location : (X, Y), speed : SP, detectionRange : T >, < S2 : Obstacle | location : (X2,Y2) >) = 
        if unavoidableCrash(< S : Robot | >, < S2 : Obstacle | >) then
            distance((X, Y), (X2,Y2)) / SP
        else
            if (distance((X, Y), (X2,Y2)) > T) then
                (distance((X, Y), (X2,Y2)) - T) / SP
            else
                distance((X, Y), (X2,Y2)) / SP
            fi 
        fi .
    eq $destinationTimeAdvance(< S : Robot | location : (X,Y), remainingPath : (X2,Y2) LL, speed : SP >, none) = distance((X,Y), (X2,Y2)) / SP .
    eq $destinationTimeAdvance(< S : Robot | >, < S2 : Robot | > CONF) = min(calculateAdvance(< S : Robot | >, < S2 : Robot | >), $destinationTimeAdvance(< S : Robot | >, CONF)) .
    
    ceq $mteRobot(S, < S : Robot | detected : REP > CONF) = 0 if REP =/= nil .
    eq $mteRobot(S, < S : Robot | location : (X,Y), remainingPath : (X,Y) LL > CONF) = 0 .
    ceq $mteRobot(S, < S : Robot | location : (X,Y), state : FUNC, curTask : TID > < S2 : ResupplySite | location : (X,Y) > CONF) = 0 if needsResupply(< S : Robot | >, TID) and (FUNC =/= resupplying) .
    ceq $mteRobot(S,< S : Robot | state : FUNC, location : (X,Y), curTask : [S2, TT, N], workState : noWork > < S2 : Field | location : (X,Y) > CONF) = 0 if canCompleteNow(< S : Robot | >, [S2, TT, N]) .
    ceq $mteRobot(S, < S : Robot | state : STATE > CONF) = 0 if STATE == planningPath .
    eq $mteRobot(S, < S : Robot | state : INC, detected : nil > CONF) = inf .
    eq $mteRobot(S, < S : Robot | state : idle, remainingPath : nil, detected : nil > CONF) = inf .
    ceq $mteRobot(S, < S : Robot | state : idle, remainingPath : LL, detected : nil > CONF) = 0 if LL =/= nil .
    ceq $mteRobot(S, < S : Robot | state : STATE, workState : [S2 TT TIME], detected : nil > CONF) = TIME if (STATE == repairing) or (STATE == removing) .
    ceq $mteRobot(S, < S : Robot | location : (X,Y), remainingPath : (X2,Y2) LL > CONF) = 
        $destinationTimeAdvance(< S : Robot | >, remove(S, closest((X2,Y2), none, sameDestination((X2,Y2), CONF))))
        if (objectInWay((X,Y), (X2,Y2), CONF) == none) .
    eq $mteRobot(S, < S : Robot | state : moving, location : (X, Y), speed : SP, remainingPath : (X2, Y2) LL, detected : nil > CONF)
    =
    calculateAdvance(< S : Robot | >, objectInWay((X, Y), (X2,Y2), CONF)) [owise] .

    eq mte(< S : Map | > CONF) = mte(CONF) .
    eq mte(< S : Field | > CONF) = min(minExpire(< S : Field | >), mte(CONF)) .
    eq mte(< S : Robot | handledTime : false > CONF) = min($mteRobot(S, < S : Robot | > CONF), mte(< S : Robot | handledTime : true > CONF)) .
    eq mte(dly(MSG, TIME) CONF) = min(TIME, mte(CONF)).
    eq mte(CONF) = inf [owise] .

    eq timeEffect(dly(MSG, TIME) CONF, TIME2) = dly(MSG, TIME monus TIME2) timeEffect(CONF, TIME) .

    ceq timeEffect(< S : Robot | state : STATE > CONF, TIME) = decreaseTimers(< S : Robot | >, TIME) timeEffect(CONF, TIME) if STATE =/= moving and STATE =/= crashed .
    eq timeEffect(< S : Robot | state : crashed > CONF, TIME) = < S : Robot | > timeEffect(CONF,TIME) .
    eq timeEffect(< S : Robot | state : moving, location : (X, Y), direction : north, speed : SP, remainingPath : (X2,Y2) LL > CONF, R) = decreaseTimers(< S : Robot | location : (X, Y + (SP * R)) >, R) timeEffect(CONF, R) .
    eq timeEffect(< S : Robot | state : moving, location : (X, Y), direction : east, speed : SP, remainingPath : (X2,Y2) LL > CONF, R) = decreaseTimers(< S : Robot | location : (X + (SP * R), Y) >, R) timeEffect(CONF, R) .
    eq timeEffect(< S : Robot | state : moving, location : (X, Y), direction : south, speed : SP, remainingPath : (X2,Y2) LL > CONF, R) = decreaseTimers(< S : Robot | location : (X, Y - (SP * R)) >, R) timeEffect(CONF, R) .
    eq timeEffect(< S : Robot | state : moving, location : (X, Y), direction : west, speed : SP, remainingPath : (X2,Y2) LL > CONF, R) = decreaseTimers(< S : Robot | location : (X - (SP * R), Y) >, R) timeEffect(CONF, R) .

    eq timeEffect(< S : Field | > CONF, TIME) = decreaseTimers(< S : Field | >, TIME) timeEffect(CONF, TIME) .
    eq timeEffect(CONF, TIME) = CONF [owise] .

    ceq detect(< S : Robot | state : FUNC, detected : REP > < S2 : Obstacle | location : (X2,Y2) > CONF) =
        detect(< S : Robot | detected : {S2 : Obstacle | (X2,Y2)} REP > < S2 : Obstacle | > CONF) if < S : Robot | > detects < S2 : Obstacle | > .
    ceq detect(< S : Robot | detected : REP, workState : WS > < S2 : Robot | state : STATE, location : (X2,Y2), direction : D, speed : SP, workState : WS2 > CONF) =
        detect(< S : Robot | detected : {S2 : Robot | (X2,Y2) ; D ; detectedSpeed(SP) ; STATE} REP > < S2 : Robot | > CONF) if (< S : Robot | > detects < S2 : Robot | >) .
    eq detect(CONF) = CONF [owise] .

    crl [timeEffect] :
        CONF @ TIME
        =>
        detect(handleCollisions(timeEffect(CONF, mte(CONF)))) @ (TIME + mte(CONF))
        if mte(CONF) > 0 and mte(CONF) < inf .
endom