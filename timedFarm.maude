load robot .
load time-inf .
load obstacle . 
load buildings .
load quadratic-solver .
omod TIMED-FARM is
    protecting ROBOT .
    protecting TIME-INF .
    protecting MAP .
    protecting FIELD .
    protecting OBSTACLE .
    protecting BUILDINGS .
    protecting QUADRATIC-SOLVER .

    ***filter based on workers/transporters/fields here? Makes most sense to facilitate multicast instead of broadcast.
    sorts ClockedConfiguration LimitClockedConfiguration .

    op  _@_ : Configuration Time -> ClockedConfiguration [ctor] .
    op _[LIMIT:_] : ClockedConfiguration Time -> LimitClockedConfiguration [ctor] .
    op $mteRobot : Object Configuration -> TimeInf .
    op $mteField : Object -> TimeInf .
    op mte : Configuration -> TimeInf .

    op $destinationTime : Object Configuration -> Time .
    op quadFormulaValidation : Rat Rat Rat -> Time .
    op quadTime : Object Object -> Time .
    op $coefficientA : Rat Rat -> Rat .
    op $coefficientB : Rat Rat Rat Rat -> Rat .
    op $coefficientC : Rat Rat Rat -> Rat .

    op timeEffect : Configuration Time -> Configuration .
    ops $timeEffectRobot $timeEffectField : Object Time -> Object .

    op $linearTime : Object Object Rat -> Time .
    op linearTime : Object Object -> Time .
    op collision : Configuration Object -> Configuration .
    op handleCollisions : Configuration -> Configuration .
    op updateLocation : Object -> Object .
    op unavoidableCrash : Object Object -> Bool .

    vars CONF CONF2 CONF3 : Configuration .
    var OBS : Configuration .
    var AUS : Set{AuctionElt} .
    vars TIME TIME2 : Time .
    var ROS : Set{RoadElt} .
    vars TR TR2 TR3 TR4 : Timer .
    var O : Object .
    vars OID OID2 OID3 : String .
    vars X X2 Y Y2 X3 Y3 : Rat .
    vars SP SP2 : Rat .
    vars DIST DIST2 : Rat .
    vars T T2 : Rat .
    vars N N' N2 N3 N4 : Nat .
    vars L L2 : Level .
    vars LCO LCO2 : List-Coordinate .
    vars I I2 : Int .
    vars D D2 : Direction .
    var STATE : State .
    vars R R2 R3 : Rat .
    vars A B C : Rat .
    var GS : GrowingState .
    var REPS : Set{RepresentationElt} .
    var FUNC : FunctioningState .
    var INC : IncapacitatedState .
    var MSG : Msg .
    var MC : MsgContent .
    vars WS WS2 : WorkState .
    var TID : Tid .
    var TT : TaskType .
    var WT : WorkerTask .
    var TPT : TransporterTask .
    var YIS : YieldInformationSet .
    var WI : WaitingInformation .
    var BIS : BaseInformationSet .

    eq $coefficientA(SP, SP2) = (SP ^ 2) + (SP2 ^ 2) .
    eq $coefficientB(SP, DIST, SP2, DIST2) = -2 * ((SP * DIST) + (SP2 * DIST2)) .
    eq $coefficientC(DIST, DIST2, T) = (DIST ^ 2) + (DIST2 ^ 2 ) + (-1 * (T ^ 2)) .

    eq quadFormulaValidation(A, B, C) =
        if posOnly(quadFormula(A, B, C)) == noResult
        then
            ratInf
        else
            minElement(posOnly(quadFormula(A, B, C)))
        fi .

    ceq quadTime(
            < OID : Robot | 
                coordinate : (X,Y), 
                speed : SP, 
                remainingPath : (X2,Y2) LCO, 
                detectionRange : T 
            >,
            < OID2 : Robot | 
                coordinate : (X3,Y3), 
                speed : SP2, 
                detectionRange : T2 
            >
        )
        =
        quadFormulaValidation(
            $coefficientA(
                SP,
                SP2
            ),
            $coefficientB(
                SP,
                distance((X,Y), (X2,Y2)),
                SP2,
                distance((X3,Y3), (X2,Y2))
            ),
            $coefficientC(
                distance((X,Y), (X2,Y2)),
                distance((X3,Y3), (X2,Y2)),
                max(T, T2)
            )
        )
        if distance((X,Y), (X3,Y3)) > max(T, T2) .

    ceq quadTime(
            < OID : Robot | coordinate : (X,Y), speed : SP, remainingPath : (X2,Y2) LCO, detectionRange : T >,
            < OID2 : Robot | coordinate : (X3,Y3), speed : SP2, detectionRange : T2 >)
        =
        quadFormulaValidation(
            $coefficientA(SP, SP2),
            $coefficientB(SP, distance((X,Y), (X2,Y2)), SP2, distance((X3,Y3), (X2,Y2))),
            $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), min(T,T2))
        )
        if distance((X,Y), (X3,Y3)) <= max(T, T2) and distance((X,Y), (X3,Y3)) > min(T, T2) .

    ceq quadTime(
            < OID : Robot | coordinate : (X,Y), speed : SP, remainingPath : (X2,Y2) LCO, detectionRange : T >,
            < OID2 : Robot | coordinate : (X3,Y3), speed : SP2, detectionRange : T2 >)
        =
        quadFormulaValidation(
            $coefficientA(SP, SP2),
            $coefficientB(SP, distance((X,Y), (X2,Y2)), SP2, distance((X3,Y3), (X2,Y2))),
            $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), FINAL-RANGE)
        )
        if distance((X,Y), (X3,Y3)) <= min(T, T2) and distance((X,Y), (X2,Y2)) > FINAL-RANGE .

    eq quadTime(
            < OID : Robot | coordinate : (X,Y), speed : SP, remainingPath : (X2,Y2) LCO, detectionRange : T >,
            < OID2 : Robot | coordinate : (X3,Y3), speed : SP2, detectionRange : T2 >)
        =
        distance((X,Y), (X2,Y2)) / SP [owise] .

    ceq quadTime(
            < OID : Robot | 
                coordinate : (X,Y), speed : SP,
                remainingPath : (X2,Y2) LCO, 
                detectionRange : T >,
            < OID2 : Obstacle | coordinate : (X3,Y3) >)
        =
        quadFormulaValidation(
            $coefficientA(SP, 0),
            $coefficientB(SP, distance((X,Y), (X2,Y2)), 0, distance((X3,Y3), (X2,Y2))),
            $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), T)
        )
        if distance((X,Y), (X3,Y3)) > T .

    ceq quadTime(
            < OID : Robot | 
                coordinate : (X,Y), speed : SP,
                remainingPath : (X2,Y2) LCO, 
                detectionRange : T >,
            < OID2 : Obstacle | coordinate : (X3,Y3) >)
        =
        quadFormulaValidation(
            $coefficientA(SP, 0),
            $coefficientB(SP, distance((X,Y), (X2,Y2)), 0, distance((X3,Y3), (X2,Y2))),
            $coefficientC(distance((X,Y), (X2,Y2)), distance((X3,Y3), (X2,Y2)), FINAL-RANGE)
        )
        if distance((X,Y), (X3,Y3)) <= T and distance((X,Y), (X3,Y3)) > FINAL-RANGE .

    eq quadTime(
            < OID : Robot | 
                coordinate : (X,Y), speed : SP,
                remainingPath : (X2,Y2) LCO, 
                detectionRange : T >,
            < OID2 : Obstacle | coordinate : (X3,Y3) >)
        =
        distance((X,Y), (X2,Y2)) / SP
        [owise] .

    eq updateLocation(< OID : Robot | coordinate : (X, Y), direction : north >) = < OID : Robot | coordinate : (X, Y - ROBOT-SIZE) > .
    eq updateLocation(< OID : Robot | coordinate : (X, Y), direction : east >) = < OID : Robot | coordinate : (X - ROBOT-SIZE, Y) > .
    eq updateLocation(< OID : Robot | coordinate : (X, Y), direction : south >) = < OID : Robot | coordinate : (X, Y + ROBOT-SIZE) > .
    eq updateLocation(< OID : Robot | coordinate : (X, Y), direction : west >) = < OID : Robot | coordinate : (X + ROBOT-SIZE, Y) > .

    eq collision(< OID : Robot | coordinate : (X, Y) > < OID2 : Obstacle | >, < OID3 : Map | >) =  updateLocation(< OID : Robot | speed : 0, state : crashed >) < OID2 : Obstacle | > .
    ceq collision(< OID : Robot | speed : SP > < OID2 : Robot | speed : SP2 >, < OID3 : Map | roads : ROS >) = 
        updateLocation(< OID : Robot | state : crashed, speed : 0 >) < OID2 : Robot | speed : 0, state : crashed >
        if outsideMap(getLocation(updateLocation(< OID : Robot | >)), ROS) == false .

    eq handleCollisions(< OID : Robot | coordinate : (X, Y) > < OID2 : PhysicalObj | coordinate : (X, Y) >  < OID3 : Map | > CONF) = collision(< OID : Robot | > < OID2 : PhysicalObj | >, < OID3 : Map | >) handleCollisions(< OID3 : Map | > CONF) .
    eq handleCollisions(CONF) = CONF [owise] .

    eq unavoidableCrash(< OID : Robot | >, none) = false .
    eq unavoidableCrash(< OID : Robot | speed : 0 >, O) = false .
    ceq unavoidableCrash(< OID : Robot | state : moving, coordinate : (X, Y), direction : D, speed : SP >, < OID2 : Robot | state : moving, coordinate : (X2, Y2), direction : D2, speed : SP2 >) = 
        if distance((X, Y), (X2, Y2)) <= stoppingDistance(< OID : Robot | >) + stoppingDistance(< OID2 : Robot | >) then
            true
        else
            false
        fi
    if oppositeDirections(D, D2) .
    eq unavoidableCrash(< OID : Robot | coordinate : (X, Y) >, < OID2 : PhysicalObj | coordinate : (X2, Y2) >) = 
        if distance((X, Y), (X2, Y2)) <= stoppingDistance(< OID : Robot | >)
        then
            true
        else
            false
        fi .
    ceq unavoidableCrash(< OID : Robot | state : moving, coordinate : (X,Y), direction : D, remainingPath : (X2,Y2) LCO, speed : SP >, < OID2 : Robot | state : moving, coordinate : (X3,Y3), direction : D2, remainingPath : (X2,Y2) LCO2, speed : SP2 >) =
        if (distance((X,Y), (X2,Y2)) / SP) == distance((X3,Y3), (X2,Y2))
        then
            true
        else
            false
        fi
        if differentAxes(D, D2) .

    ***Calculates time until intersection with one of the detection borders.
    ceq $linearTime(< OID : Robot | coordinate : (X,Y), detectionRange : T >,
            < OID2 : Robot | coordinate : (X2,Y2), detectionRange : T2 >, SP)
        =
        (distance((X,Y), (X2,Y2)) - max(T,T2)) / SP
        if distance((X,Y), (X2,Y2)) > max(T, T2) .
    
    ceq $linearTime(< OID : Robot | coordinate : (X,Y), detectionRange : T >,
            < OID2 : Robot | coordinate : (X2,Y2), detectionRange : T2 >, SP)
        =
        (distance((X,Y), (X2,Y2)) - min(T,T2)) / SP
        if (distance((X,Y), (X2,Y2)) > min(T, T2)) and (distance((X,Y), (X2,Y2)) < max(T, T2)) .
    
    ceq $linearTime(< OID : Robot | coordinate : (X,Y), detectionRange : T >,
            < OID2 : Robot | coordinate : (X2,Y2), detectionRange : T2 >, SP)
        =
        (distance((X,Y), (X2,Y2)) - FINAL-RANGE) / SP
        if (distance((X,Y), (X2,Y2)) > FINAL-RANGE) and (distance((X,Y), (X2,Y2)) < min(T, T2)) .
    
    eq $linearTime(< OID : Robot | coordinate : (X,Y) >,
            < OID2 : Robot | coordinate : (X2,Y2) >, SP)
        =
        distance((X,Y), (X2,Y2)) / SP [owise] .

    ***If a robot is behind another in the same direction check time until detection happens.
    ***What if moving out of detection range?
    ***TODO: Incorporate unavoidableCrash here.
    ***Not true collision modelling, since a lower time interruption can cause detection.
    ***Ignore detection if true collision is unavoidable for sensors?
    ***Or mention it as a weakness.
    eq linearTime(< OID : Robot | speed : SP, direction : D >, 
            < OID2 : Robot | state : moving, speed : SP2, direction : D >) 
        = 
        if SP2 >= SP then
            ratInf  
        else
            $linearTime(< OID : Robot | >, < OID2 : Robot | >, SP - SP2)
        fi .
    ***Check detection if two robots are moving towards one another
    ceq linearTime(< OID : Robot | state : moving, speed : SP, direction : D >, 
            < OID2 : Robot | state : moving, speed : SP2, direction : D2 >) 
        = 
        $linearTime(< OID : Robot | >, < OID2 : Robot | >, SP + SP2)
        if oppositeDirections(D,D2) .
    ***If the second robot is unmoving, check time until detection happens based on first robot's speed.
    ceq linearTime(< OID : Robot | state : moving, speed : SP >, 
            < OID2 : Robot | state : STATE >) 
        =
        $linearTime(< OID : Robot | >, < OID2 : Robot | >, SP)
        if STATE =/= moving .
    
    eq linearTime(< OID : Robot | state : moving, coordinate : (X, Y), speed : SP, detectionRange : T >,
        < OID2 : Obstacle | coordinate : (X2,Y2) >) = 
        if unavoidableCrash(< OID : Robot | >, < OID2 : Obstacle | >) then
            distance((X, Y), (X2,Y2)) / SP
        else
            if (distance((X, Y), (X2,Y2)) > T) then
                (distance((X, Y), (X2,Y2)) - T) / SP
            else
                if distance((X,Y), (X2,Y2)) > FINAL-RANGE
                then
                    (distance((X,Y), (X2,Y2)) - FINAL-RANGE) / SP
                else
                    distance((X,Y), (X2,Y2)) / SP
                fi
            fi 
        fi .

    ***Time to reach next waypoint when there is no other object in the way
    eq $destinationTime(
         < OID : Robot | 
            coordinate : (X, Y), 
            remainingPath : (X2, Y2) LCO, 
            speed : SP >,
         none
       )
       =
       distance((X, Y), (X2, Y2)) / SP .

    ***what about an object that is leaving?
    eq $destinationTime(
        < OID : Robot | direction : D >,
        < OID2 : Robot | direction : D2 > CONF
        ) 
        =
        if differentAxes(D, D2)
        then
            min(
                quadTime(< OID : Robot | >, < OID2 : Robot | >),
                $destinationTime(< OID : Robot | >, CONF)
            )
        else
            min(
                linearTime(< OID : Robot | >, < OID2 : Robot | >),
                $destinationTime(< OID : Robot | >, CONF)
            )
        fi .

    eq $destinationTime(
        < OID : Robot | 
            coordinate : (X,Y), 
            remainingPath : (X2,Y2) LCO >,
        < OID2 : Obstacle | coordinate : (X3,Y3) > CONF
        ) 
        =
        if differentAxes(setDirection((X,Y), (X2,Y2)), setDirection((X2,Y), (X3,Y3)))
        then
            min(
                quadTime(< OID : Robot | >, < OID2 : Obstacle | >),
                $destinationTime(< OID : Robot | >, CONF)
            )       
        else
            min(
                linearTime(< OID : Robot | >, < OID2 : Obstacle | >),
                $destinationTime(< OID : Robot | >, CONF)
            )
        fi .

    ***Needs to start working on a field
    ceq $mteRobot(< OID : Robot | coordinate : (X,Y), curTask : [OID2, TT], workState : noWork >,
        < OID2 : Field | coordinate : (X,Y) > CONF) = 
        0 if canComplete(< OID : Robot | >, [OID2, TT]) .
    ***Needs to finish working on a field.
    eq $mteRobot(< OID : Worker | coordinate : (X,Y), state : FUNC, remainingPath : nil, workState : [OID2, WT], cargoLevel : full >,
      < OID2 : Field | coordinate : (X,Y) > CONF) = 0 .
    eq $mteRobot(< OID : Transporter | coordinate : (X,Y), state : FUNC, remainingPath : nil, workState : [OID2, TPT], cargoLevel : emptyCargo >,
        < OID2 : Field | coordinate : (X,Y) > CONF) = 0 .
    ***Don't advance time if a robot needs to parse through detections
    ceq $mteRobot(< OID : Robot | detected : REPS >, CONF) = 0 if REPS =/= empty .    
    ***Needs to potentially change directions
    eq $mteRobot(< OID : Robot | state : moving, coordinate : (X,Y), remainingPath : (X,Y) LCO >, CONF) = 0 .
    ***Needs to stop negotiating
    eq $mteRobot(< OID : Robot | state : negotiating, negotiations : none >,  CONF) = 0 .
    ***Needs to transition to planningPath
    eq $mteRobot(< OID : Robot | state : idle, remainingPath : nil, yieldStatus : noYieldInformation, curTask : TID >,  CONF) = 0 .
    ***Needs to stop waiting
    eq $mteRobot(< OID : Robot | state : waiting, waitingStatus : noWaitingInformation >, CONF) = 0 .
    ***Allow robot to start resupplying if needed
    ceq $mteRobot(< OID : Robot | coordinate : (X,Y), state : FUNC, curTask : TID >,
    < OID2 : ResupplyStation | coordinate : (X,Y) > CONF) = 0 if needsResupply(< OID : Robot | >, TID) and (FUNC =/= resupplying) .
    ***finish resupply.
    eq $mteRobot(< OID : Robot | coordinate : (X,Y), state : resupplying, workState : [OID2, resupplyTask, 0] >,
      < OID2 : ResupplyStation | coordinate : (X,Y) > CONF) = 0 .
    ***Need to start unloading
    eq $mteRobot(< OID : Robot | coordinate : (X,Y), state : FUNC, cargoLevel : full, workState : noWork >,
        < OID2 : CollectionStation | coordinate : (X,Y) > CONF) = 0 .
    ***Need to finish unloading
    eq $mteRobot(< OID : Robot | coordinate : (X,Y), state : unloading, cargoLevel : full, workState : [OID2, unloadTask, 0] >,
        < OID2 : CollectionStation | coordinate : (X,Y) > CONF) = 0 .
    ***Needs to start replanning path.
    eq $mteRobot(< OID : Robot | state : planningPath >, CONF) = 0 .
    ***Needs to start movement
    ceq $mteRobot(< OID : Robot | state : idle, remainingPath : LCO, detected : empty >, CONF) = 0 if LCO =/= nil .
    ***Not relevant if incapacitated, negotiating, idle or waiting
    ***An explanation for this, it cannot move
    eq $mteRobot(< OID : Robot | state : INC, detected : empty >, CONF) = ratInf .
    eq $mteRobot(< OID : Robot | state : negotiating, detected : empty >, CONF) = ratInf .
    eq $mteRobot(< OID : Robot | state : idle, remainingPath : nil, detected : empty >, CONF) = ratInf .
    eq $mteRobot(< OID : Robot | state : waiting, waitingStatus : [BIS | TR | TR2] >, CONF) = ratInf .
    ***time until timedWork is completed.
    eq $mteRobot(< OID : Robot | state : FUNC, workState : [OID2, TT, TIME], detected : empty >, CONF) = TIME .

    ***Unobstructed movement
    ***If it is moving uninterrupted towards an intersection then check until it may detect other robots that are close to that intersection
    ceq $mteRobot(
        < OID : Robot | 
            state : moving, 
            coordinate : (X,Y), 
            remainingPath : (X2,Y2) LCO >,
        CONF
        )
        =
        $destinationTime(
            < OID : Robot | >,
            closestPhysObjs((X2,Y2), none, getPhysObjs(CONF))
        )
        if (objectInWay((X,Y), (X2,Y2), CONF) == none) .

    ***The previous equation won't apply if there is a robot located at the intersection the robot is moving away from it.
    ***This equation ensures that destinationTimeAdvance is still applied in such a scenario.
    ***The condition checks if the first object in the way is a robot 
    ceq $mteRobot(
            < OID : Robot | 
                state : moving, 
                coordinate : (X,Y), 
                remainingPath : (X2,Y2) LCO, 
                direction : D >,
            < OID2 : Robot | 
                state : moving, 
                coordinate : (X2,Y2), 
                direction : D2 > 
            CONF
        )
        =
        $destinationTime(
            < OID : Robot | >,
            closestPhysObjs((X2,Y2), none, getPhysObjs(CONF))
        )
        if (getOid(objectInWay((X,Y), (X2,Y2), < OID2 : Robot | > CONF)) == OID2)
            and not oppositeDirections(D, D2) .

    eq $mteRobot(
            < OID : Robot | state : moving, coordinate : (X,Y),
                remainingPath : (X2, Y2) LCO, detected : empty >,
            CONF
        )
        =
        linearTime(< OID : Robot | >, objectInWay((X,Y), (X2,Y2), CONF)) [owise] .

    ceq $mteField(< OID : Field | >) = 0 if needToStartAuction(< OID : Field | >) .
    eq $mteField(< OID : Field | auctions : AUS >) = 
        minTimer(getAuctionTimers(AUS) 
            activeWaterTimer(< OID : Field | >) 
            activeFertilizerTimer(< OID : Field | >) 
            activeGrowTimer(< OID : Field | >)) .

    eq mte(< OID : Robot | handledTime : false > CONF) =
        min(minTimer(getTimers(< OID : Robot | >)),
        min($mteRobot(< OID : Robot | >, CONF),
        mte(< OID : Robot | handledTime : true > CONF))) .
    eq mte(< OID : Field | > CONF) =
        min($mteField(< OID : Field | >), mte(CONF)) .

    eq mte(dly(MSG, TIME) CONF) = min(TIME, mte(CONF)).
    eq mte(CONF) = ratInf [owise] .

    eq $timeEffectRobot(< OID : Robot | state : moving, 
            coordinate : (X, Y), 
            direction : north, 
            speed : SP, 
            remainingPath : (X2,Y2) LCO >, 
        TIME) 
        = 
        < OID : Robot | coordinate : (X, Y + (SP * TIME)) > .

    eq $timeEffectRobot(< OID : Robot | state : moving, 
            coordinate : (X, Y), 
            direction : east, 
            speed : SP, 
            remainingPath : (X2,Y2) LCO >, 
        TIME) 
        = 
        < OID : Robot | coordinate : (X + (SP * TIME), Y) > .

    eq $timeEffectRobot(< OID : Robot | state : moving, 
            coordinate : (X, Y), 
            direction : south, 
            speed : SP, 
            remainingPath : (X2,Y2) LCO >, 
        TIME) 
        = 
        < OID : Robot | coordinate : (X, Y - (SP * TIME)) > .

    eq $timeEffectRobot(< OID : Robot | state : moving, 
            coordinate : (X, Y), 
            direction : west, 
            speed : SP, 
            remainingPath : (X2,Y2) LCO >, 
        TIME) 
        = 
        < OID : Robot | coordinate : (X - (SP * TIME), Y) > .

    ceq $timeEffectRobot(< OID : Robot | state : STATE >, 
        TIME) 
        = 
        < OID : Robot | > 
        if STATE =/= moving .

    eq timeEffect(< OID : Robot | > CONF, TIME) 
        = 
        $timeEffectRobot(
            decreaseTimers(< OID : Robot | >, TIME),
            TIME
        ) 
        timeEffect(CONF, TIME) .
    eq timeEffect(< OID : Field | > CONF, TIME) = decreaseTimers(< OID : Field | >, TIME) timeEffect(CONF, TIME) .
    eq timeEffect(dly(MSG, TIME) CONF, TIME2) = dly(MSG, TIME monus TIME2) timeEffect(CONF, TIME) .
    eq timeEffect(CONF, TIME) = CONF [owise] .

    ***Add some sort of limiter to clocked configuration, or a new sort?
    ***Then in the condition add monus for the limiter if mte(CONF) + TIME <= LIMIT.
    crl [timeEffect] :
        CONF @ TIME 
        =>
        detect(handleCollisions(timeEffect(CONF, mte(CONF)))) @ (TIME + mte(CONF))
        if mte(CONF) > 0 and mte(CONF) < ratInf .

    crl [limitTimeEffect] :
        CONF @ TIME [LIMIT: TIME2]
        =>
        detect(handleCollisions(timeEffect(CONF, mte(CONF)))) @ (TIME + mte(CONF)) [LIMIT: TIME2]
        if mte(CONF) > 0 and mte(CONF) < ratInf and (TIME + mte(CONF) <= TIME2) .
endom