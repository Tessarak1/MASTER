load map .
load rat-inf .
omod DIJKSTRA-EDGE is
    protecting MAP .
    protecting RAT-INF .
    
    sort DijkstraEdge .
    op [_,_,_] : Object RatInf Oid -> DijkstraEdge [ctor] .
    op getCurDist : DijkstraEdge -> RatInf .
    op getIntersection : DijkstraEdge -> Object .

    var O : Object . 
    var RI : RatInf .
    var OID : Oid .

    eq getCurDist([O, RI, OID]) = RI .
    eq getIntersection([O, RI, OID]) = O .
endom

omod PRIORITY-QUEUE is
    protecting DIJKSTRA-EDGE .

    sort PQueue .
    subsort DijkstraEdge < PQueue .

    op noQueue : -> PQueue [ctor] .
    op __ : PQueue PQueue -> PQueue [assoc id: noQueue ctor] .
    op put : DijkstraEdge PQueue -> PQueue .

    var DE : DijkstraEdge .
    var PQ : PQueue .
    vars O O2 : Object .
    var OID OID2 : Oid .
    vars RI RI2 : RatInf .

    eq put(DE, noQueue) = DE .
    eq put([O, RI, OID], [O2, RI2, OID2] PQ) = if (RI < RI2) then [O, RI, OID] [O2, RI2, OID2] PQ else [O2, RI2, OID2] put([O, RI, OID], PQ) fi .
endom

omod PATHFINDER is
    protecting PRIORITY-QUEUE .

    op PQConvert : Location Configuration -> PQueue .
    op updateNeighbors : DijkstraEdge PQueue -> PQueue .
    op updateDistances : PQueue -> PQueue .
    op $buildPath : Oid PQueue -> List-Location .
    op buildPath : Oid Oid PQueue -> List-Location .
    op dijkstraSearch : Configuration Oid Oid -> List-Location .
    op dijkstraSearch : Configuration Location Location -> List-Location .
    op dijkstraChain : Configuration OidList -> List-Location .
    op dijkstraChain : Configuration List-Location -> List-Location .
    ops coverVertical coverHorizontal : List-Location List-Location -> List-Location .
    ops coverArea $coverArea : Location Area -> List-Location .
    op backToStart : Location Location -> List-Location .

    vars I I2 : Object .
    var CONF : Configuration .
    vars OS OS2 : OidSet .
    var OL : OidList .
    vars X X2 X3 X4 Y Y2 Y3 Y4 : Rat .
    vars OID OID2 OID3 OID4 : Oid .
    vars PQ PQ2 : PQueue .
    vars RI RI2 : RatInf .
    var DE : DijkstraEdge .
    var A : Area .
    var LL : List-Location .

    eq PQConvert((X,Y), none) = noQueue .
    eq PQConvert((X,Y), < OID : Intersection | location : (X,Y) > CONF) = [< OID : Intersection | >, 0, "Start"] PQConvert((X,Y), CONF) .   
    eq PQConvert((X,Y), I2 CONF) = [I2, ratInf, "Placeholder"] PQConvert((X,Y), CONF) [owise] .

    eq updateNeighbors([< OID : Intersection | neighbors : none >, RI, OID2], PQ) = PQ .
    eq updateNeighbors([< OID : Intersection | location : (X,Y), neighbors : OID2 OS >, RI, OID3], PQ [< OID2 : Intersection | location : (X2,Y2), neighbors : OID OS2 >, RI2, OID4] PQ2) =
        if (distance((X,Y), (X2,Y2)) + RI) < RI2 then
            updateNeighbors([< OID : Intersection | neighbors : OS >, RI, OID3], put([< OID2 : Intersection | neighbors : OS2 >, distance((X,Y), (X2,Y2)) + RI, OID], PQ PQ2))
        else
            updateNeighbors([< OID : Intersection | neighbors : OS >, RI, OID3], PQ [< OID2 : Intersection | neighbors : OS2 >, RI2, OID4] PQ2)
        fi .
    eq updateDistances(noQueue) = noQueue .
    eq updateDistances(DE PQ) = DE updateDistances(updateNeighbors(DE, PQ)) .
    
    eq $buildPath(OID, PQ [< OID : Intersection | location : (X,Y) >, RI, "Start"] PQ2) = nil .
    ceq $buildPath(OID, PQ [< OID : Intersection | location : (X,Y) >, RI, OID2] PQ2) = $buildPath(OID2, PQ PQ2) (X,Y) if OID2 =/= "Start" .
    eq $buildPath(OID, PQ) = nil [owise] .
    
    eq buildPath(OID, OID2, PQ [< OID2 : Intersection | location : (X,Y) >, RI, OID3] PQ2) = $buildPath(OID3, PQ) (X,Y) .

    eq dijkstraSearch(< OID : Intersection | location : (X,Y) > CONF, OID, OID2) = buildPath(OID, OID2, updateDistances(PQConvert((X,Y), < OID : Intersection | > CONF))) .
    eq dijkstraSearch(CONF, (X,Y), (X,Y)) = nil .
    eq dijkstraSearch(< OID : Intersection | location : (X,Y) > < OID2 : Intersection | location : (X2,Y2) > CONF, (X,Y), (X2,Y2)) =
        dijkstraSearch(< OID : Intersection | location : (X,Y) > < OID2 : Intersection | location : (X2,Y2) > CONF, OID, OID2) .

    eq dijkstraChain(CONF, OID ; OID2) = dijkstraSearch(CONF, OID, OID2) .
    eq dijkstraChain(CONF, OID ; OID2 ; OL) = dijkstraSearch(CONF, OID, OID2) dijkstraChain(CONF, OID2 ; OL) .
    eq dijkstraChain(CONF, (X,Y) (X2,Y2)) = dijkstraSearch(CONF, (X,Y), (X2,Y2)) .
    eq dijkstraChain(CONF, (X,Y) (X2,Y2) LL) = dijkstraSearch(CONF, (X,Y), (X2,Y2)) dijkstraChain(CONF, (X2,Y2) LL) .
    eq backToStart((X,Y), (X2,Y2)) = (X,Y2) (X2,Y2) .
    eq coverHorizontal((X,Y) (X2, Y), (X,Y) (X2,Y)) = nil .
    eq coverHorizontal((X,Y) (X2, Y), (X2,Y) (X,Y)) = nil .
    eq coverHorizontal((X,Y) (X2,Y), (X3,Y2) (X4,Y2)) =
        if Y < Y2
        then 
            (X2, Y + 1) (X, Y + 1) coverHorizontal((X2, Y + 1) (X, Y + 1), (X,Y2) (X2,Y2))
        else 
            (X2, Y - 1) (X, Y - 1) coverHorizontal((X2, Y - 1) (X, Y - 1), (X,Y2) (X2,Y2))
        fi .
    
    eq coverVertical((X,Y) (X, Y2), (X,Y) (X,Y2)) = nil .
    eq coverVertical((X,Y) (X,Y2), (X,Y2) (X,Y)) = nil .
    eq coverVertical((X,Y) (X,Y2), (X2,Y3) (X2, Y4)) = 
        if X < X2
        then 
            (X + 1, Y2) (X + 1, Y) coverVertical((X + 1, Y2) (X + 1, Y), (X2,Y) (X2, Y2))
        else 
            (X - 1, Y2) (X - 1, Y) coverVertical((X - 1, Y2) (X - 1, Y), (X2,Y) (X2, Y2))
        fi .
    eq $coverArea((X,Y3), area((X,Y), (X2,Y), (X,Y2), (X2,Y2))) = (X,Y) (X,Y2) coverVertical((X,Y) (X,Y2), (X2,Y) (X2,Y2)) .
    eq $coverArea((X3,Y), area((X,Y), (X2,Y), (X,Y2), (X2,Y2))) = (X,Y) (X2,Y) coverHorizontal((X,Y) (X2,Y), (X,Y2) (X2,Y2)).
    eq coverArea((X,Y), A) = $coverArea((X,Y), A) backToStart(last($coverArea((X,Y), A)), (X,Y)) .
endom   
