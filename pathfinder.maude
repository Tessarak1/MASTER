load map .
load rat-inf .
omod DIJKSTRA-NODE is
    protecting MAP .
    protecting RAT-INF .
    
    sort dijkstraNode .
    ***Intersection, current calculated distance to it
    ***and Oid of previous intersection of shortest path to it.
    op [_,_,_] : Object RatInf Oid -> dijkstraNode [ctor] .
endom

omod PRIORITY-QUEUE is
    protecting DIJKSTRA-NODE .

    sort PQueue .
    subsort dijkstraNode < PQueue .

    ***basic list constructors
    op noQueue : -> PQueue [ctor] .
    op __ : PQueue PQueue -> PQueue [assoc id: noQueue ctor] .

    ***adds node to list, sorted by current shortest distance to node.
    op put : dijkstraNode PQueue -> PQueue .

    var DN : dijkstraNode .
    var PQ : PQueue .
    vars O O2 : Object .
    var OID OID2 : Oid .
    vars RI RI2 : RatInf .

    eq put(DN, noQueue) = DN .
    eq put([O, RI, OID], [O2, RI2, OID2] PQ) =
        if (RI < RI2)
        then
            [O, RI, OID] [O2, RI2, OID2] PQ
        else
            [O2, RI2, OID2] put([O, RI, OID], PQ)
        fi .
endom

omod PATHFINDER is
    protecting PRIORITY-QUEUE .

    ***Converts a set of intersections into a priority queue starting with the intersection with the given location.
    op PQConvert : Configuration Location -> PQueue .

    ***Updates the distances to an edge's neighbors 
    op updateNeighbors : dijkstraNode PQueue -> PQueue .
    
    ***recursively calls updateNeighbors to update all distances
    op updateDistances : PQueue -> PQueue .

    ***construct path from goal node to starting node.
    ***Starts from goal node and traces back previous nodes until starting node is reached.
    ***returns nil if no path is possible
    op buildPath : Oid PQueue -> List-Location .

    ***Constructs shortest path from intersection with first oid to intersection with second oid.
    op dijkstraSearch : Configuration Oid Oid -> List-Location .

    ***can also do dijkstra search from location to location
    op dijkstraSearch : Configuration Location Location -> List-Location .

    ***Performs consecutive dijkstra searches when a sequence of locations need to be visited in order
    op dijkstraChain : Configuration List-Location -> List-Location .

    ***Creates alternating respectively vertical or horizontal lines, used when a robot needs to perform a task on a field.
    ops coverVertical coverHorizontal : List-Location List-Location -> List-Location .
    
    ***creates a two step path from the first to the second location, assumes a square area.
    op backToStart : Location Location -> List-Location .

    ***Uses the previous cover operations and backToStart to create a path for the robot to cover the given area.
    ops coverArea $coverArea : Location Area -> List-Location .

    vars I I2 : Object .
    var CONF : Configuration .
    vars OS OS2 : OidSet .
    var OL : OidList .
    vars X X2 X3 X4 Y Y2 Y3 Y4 : Rat .
    vars OID OID2 OID3 OID4 : Oid .
    vars PQ PQ2 : PQueue .
    var R : Rat .
    vars RI RI2 : RatInf .
    var DN : dijkstraNode .
    var A : Area .
    var LL : List-Location .

    eq PQConvert(none, (X,Y)) = noQueue .
    eq PQConvert(< OID : Intersection | location : (X,Y) > CONF, (X,Y)) = [< OID : Intersection | >, 0, "Start"] PQConvert(CONF, (X,Y)) .   
    eq PQConvert(I2 CONF, (X,Y)) = [I2, ratInf, "Placeholder"] PQConvert(CONF, (X,Y)) [owise] .

    eq updateNeighbors([< OID : Intersection | neighbors : none >, RI, OID2], PQ) = PQ .
    eq updateNeighbors([< OID : Intersection | location : (X,Y), neighbors : OID2 OS >, RI, OID3], PQ [< OID2 : Intersection | location : (X2,Y2), neighbors : OID OS2 >, RI2, OID4] PQ2) =
        if (distance((X,Y), (X2,Y2)) + RI) < RI2 then
            updateNeighbors([< OID : Intersection | neighbors : OS >, RI, OID3], put([< OID2 : Intersection | neighbors : OS2 >, distance((X,Y), (X2,Y2)) + RI, OID], PQ PQ2))
        else
            updateNeighbors([< OID : Intersection | neighbors : OS >, RI, OID3], PQ [< OID2 : Intersection | neighbors : OS2 >, RI2, OID4] PQ2)
        fi .
    eq updateDistances(noQueue) = noQueue .
    eq updateDistances(DN PQ) = DN updateDistances(updateNeighbors(DN, PQ)) .
    
    eq buildPath(OID, PQ [< OID : Intersection | >, ratInf, OID2] PQ2) = nil .
    eq buildPath(OID, PQ [< OID : Intersection | location : (X,Y) >, R, "Start"] PQ2) = (X,Y) .
    ceq buildPath(OID, PQ [< OID : Intersection | location : (X,Y) >, R, OID2] PQ2) = buildPath(OID2, PQ PQ2) (X,Y) if OID2 =/= "Start" .
    eq buildPath(OID, PQ [< OID : Intersection | location : (X,Y) >, R, OID2] PQ2) = buildPath(OID2, PQ) (X,Y) .

    eq dijkstraSearch(< OID : Intersection | location : (X,Y) > CONF, OID, OID2) = buildPath(OID2, updateDistances(PQConvert(< OID : Intersection | > CONF, (X,Y)))) .
    eq dijkstraSearch(CONF, (X,Y), (X,Y)) = nil .
    eq dijkstraSearch(< OID : Intersection | location : (X,Y) > < OID2 : Intersection | location : (X2,Y2) > CONF, (X,Y), (X2,Y2)) =
        dijkstraSearch(< OID : Intersection | location : (X,Y) > < OID2 : Intersection | location : (X2,Y2) > CONF, OID, OID2) .

    --- eq dijkstraChain(CONF, OID ; OID2) = dijkstraSearch(CONF, OID, OID2) .
    --- eq dijkstraChain(CONF, OID ; OID2 ; OL) = dijkstraSearch(CONF, OID, OID2) dijkstraChain(CONF, OID2 ; OL) .
    eq dijkstraChain(CONF, (X,Y) (X2,Y2)) = dijkstraSearch(CONF, (X,Y), (X2,Y2)) .
    eq dijkstraChain(CONF, (X,Y) (X2,Y2) LL) = dijkstraSearch(CONF, (X,Y), (X2,Y2)) dijkstraChain(CONF, (X2,Y2) LL) .

    eq backToStart((X,Y), (X2,Y2)) = (X,Y2) (X2,Y2) .
    eq coverHorizontal((X,Y) (X2, Y), (X,Y) (X2,Y)) = nil .
    eq coverHorizontal((X,Y) (X2, Y), (X2,Y) (X,Y)) = nil .
    eq coverHorizontal((X,Y) (X2,Y), (X3,Y2) (X4,Y2)) =
        if Y < Y2
        then 
            (X2, Y + 1) (X, Y + 1) coverHorizontal((X2, Y + 1) (X, Y + 1), (X,Y2) (X2,Y2))
        else 
            (X2, Y - 1) (X, Y - 1) coverHorizontal((X2, Y - 1) (X, Y - 1), (X,Y2) (X2,Y2))
        fi .
    
    eq coverVertical((X,Y) (X, Y2), (X,Y) (X,Y2)) = nil .
    eq coverVertical((X,Y) (X,Y2), (X,Y2) (X,Y)) = nil .
    eq coverVertical((X,Y) (X,Y2), (X2,Y3) (X2, Y4)) = 
        if X < X2
        then 
            (X + 1, Y2) (X + 1, Y) coverVertical((X + 1, Y2) (X + 1, Y), (X2,Y) (X2, Y2))
        else 
            (X - 1, Y2) (X - 1, Y) coverVertical((X - 1, Y2) (X - 1, Y), (X2,Y) (X2, Y2))
        fi .

    eq $coverArea((X,Y3), area((X,Y), (X2,Y), (X,Y2), (X2,Y2))) = (X,Y) (X,Y2) coverVertical((X,Y) (X,Y2), (X2,Y) (X2,Y2)) .
    eq $coverArea((X3,Y), area((X,Y), (X2,Y), (X,Y2), (X2,Y2))) = (X,Y) (X2,Y) coverHorizontal((X,Y) (X2,Y), (X,Y2) (X2,Y2)).
    
    eq coverArea((X,Y), A) = $coverArea((X,Y), A) backToStart(last($coverArea((X,Y), A)), (X,Y)) .
endom   