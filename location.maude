fmod LOCATION is 
    protecting CONVERSION .
    ***Sort Area denotes a rectangular area, the locationSet denotes the four corners of said area.
    sorts Location LocationSet Area .
    subsort Location < LocationSet .
    op ((_,_)) : Rat Rat -> Location [ctor] .
    op none : -> LocationSet [ctor] .
    op _,_ : LocationSet LocationSet -> LocationSet [ctor assoc comm] .
    op area : LocationSet -> Area [ctor] .

    op _inInterval(_,_) : Rat Rat Rat -> Bool .

    op distance : Location Location -> Rat [comm] .
    op sqrt : Rat -> Rat .
    
    ***Checks if a point is inside an area.
    op _inArea_ : Location Area -> Bool .
    op makeArea : Location Rat -> Area .
    
    vars X X2 X3 Y Y2 Y3 : Rat .
    vars R R2 R3 : Rat .

    ceq X inInterval(X2, X3) = true if (X >= min(X2,X3) and X <= max(X2,X3)) .
    eq X inInterval(X2,X3) = false [owise] .
    eq sqrt(R) = rat(sqrt(float(R))) .
    eq distance((X,Y), (X2,Y2)) = sqrt(((X - X2) ^ 2) + ((Y - Y2) ^ 2)) .
    
    ceq (X,Y) inArea area((X2,Y2), (X3,Y2), (X3,Y3), (X2, Y3)) = true if (X inInterval(X2,X3) and Y inInterval(Y2,Y3)) .
    eq (X,Y) inArea area((X2,Y2), (X3,Y2), (X3,Y3), (X2,Y3)) = false [owise] .

    eq makeArea((X,Y), R) = area((X + R, Y + R),(X + R, Y - R), (X - R, Y + R), (X - R, Y - R)) .
endfm

fmod DIRECTION is
    protecting LOCATION .
    sort Direction .

    op setDirection : Location Location -> Direction .
    ops north east south west : -> Direction [ctor] .
    op oppositeDirections : Direction Direction -> Bool [comm] .
    op differentAxes : Direction Direction -> Bool [comm] .

    vars D D2 : Direction .

    eq oppositeDirections(north, south) = true .
    eq oppositeDirections(east, west) = true .
    eq oppositeDirections(D, D2) = false [owise] .

    eq differentAxes(north, west) = true .
    eq differentAxes(north, east) = true .
    eq differentAxes(south, west) = true .
    eq differentAxes(south, east) = true .
    eq differentAxes(D, D2) = false [owise] .
endfm

fmod LIST-LOCATION is
    protecting DIRECTION .
    sort List-Location .
    subsort Location < List-Location .

    op nil : -> List-Location [ctor] .
    op __ : List-Location List-Location -> List-Location [assoc id: nil ctor] .

    ***Basic list operators
    op first : List-Location -> Location .
    op last : List-Location -> Location  .
    op remove : List-Location List-Location -> List-Location .
    ***Checks if a given locations is between two neighboring locations in the list, and returns them if they exist.
    op between : Location List-Location -> List-Location .
    ***The total distance required to traverse the entire list.
    op listLength : List-Location -> Rat .
    ***Checks for overlap between two paralell lines
    op overlap : List-Location List-Location -> Bool [comm] .
    op removeNeighborDuplicates : List-Location -> List-Location .
    ***Checks if the path represented by the second list is an obstruction for the first.
    op pathConflict : List-Location List-Location -> Bool .

    vars LL LL2 LL3 LL4 : List-Location .
    vars L L2 : Location .
    vars X X2 X3 X4 Y Y2 Y3 Y4 : Rat .

    eq first(nil) = nil .
    eq first(L LL) = L .

    eq last(nil) = nil .
    eq last(LL L) = L .

    eq between(L, nil) = nil .
    eq between(L, (X,Y)) = nil .
    eq between((X, Y), (X2, Y2) (X3, Y3) LL) =
        if ((X inInterval(X2,X3)) and (Y inInterval(Y2,Y3))) then
            (X2, Y2) (X3,Y3)
        else
            between((X,Y), (X3,Y3) LL)
        fi .

    eq remove(nil, LL) = nil .
    eq remove(LL, nil) = LL .
    eq remove(LL (X,Y) LL2, LL3 (X,Y) LL4) = remove(LL LL2, LL3 LL4) .
    eq remove(LL, LL2) = LL [owise] .

    eq listLength((X,Y) (X2,Y2) LL) = distance((X,Y), (X2,Y2)) + listLength((X2,Y2) LL) .
    eq listLength((X,Y) (X2,Y2)) = distance((X,Y), (X2,Y2)) .
    eq listLength(LL) = 0 [owise] .

    eq overlap((X,Y) (X,Y2), (X,Y3) (X,Y4)) = max(min(Y,Y2), min(Y3,Y4)) <= min(max(Y,Y2), max(Y3,Y4)) .
    eq overlap((X,Y) (X2,Y), (X3,Y) (X4,Y)) = max(min(X,X2), min(X3,X4)) <= min(max(X,X2), max(X3,X4)) .
    eq overlap(LL, LL2) = false [owise] .

    eq removeNeighborDuplicates(LL (X,Y) (X,Y) LL2) = removeNeighborDuplicates(LL (X,Y) LL2) .
    eq removeNeighborDuplicates(LL) = LL [owise] .

    ***There is a path conflict if the paths share an intersection from different direction, or if they share a path going in opposite directions
    ceq pathConflict(LL (X,Y) (X2,Y2) LL2, LL3 (X3,Y3) (X2,Y2) LL4) = true if setDirection((X,Y),(X2,Y2)) =/= setDirection((X3,Y3), (X2,Y2)) . 
    ceq pathConflict(LL (X,Y) (X2,Y2) LL2, LL3 (X3,Y3) (X4,Y4) LL4) = true if
        overlap((X,Y) (X2,Y2), (X3,Y3) (X4,Y4)) and oppositeDirections(setDirection((X,Y), (X2,Y2)), setDirection((X3,Y3), (X4,Y4))) .
    eq pathConflict(LL, (X,Y)) = between((X,Y), LL) =/= nil .
    eq pathConflict(LL, LL2) = false [owise] .
endfm