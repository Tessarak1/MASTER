load message .
load auction .

omod AUCTIONEER is
    protecting AUCTION .
    protecting MESSENGER .

    ***BidMsg sort to differentiate from other messages when pattern matching.
    sorts BidMsgContent AuctionMsgContent .
    subsort BidMsgContent AuctionMsgContent < MsgContent .

    class Auctioneer | auctions : Set{AuctionElt} .
    
    subclass Auctioneer < Messenger .

    ***Message content to facilitate auctions
    op bid_on_ : Cost Tid -> BidMsgContent [ctor] .
    op busy_ : Tid -> BidMsgContent [ctor] .
    ops won_ reject_ accept_ : Tid -> AuctionMsgContent [ctor] .

    ***Creates an auction for every task in the TidSet and broadcasts it within range.
    op initiateAuction : Object MSet{TidElt} Configuration -> Configuration .

    ***Overloaded in subclasses to determine if theo bject needs to start auctioning a task.
    op needToStartAuction : Object -> Bool .

    ***winAuction is overloaded in robot. Determines if it accepts the task or not.
    op winAuction : Object Tid -> Configuration .

    ***Object tries an auction again.
    op retryAuction : Object Configuration Auction -> Object .

    vars OID OID2 : Oid .
    var R : Rat .
    var TID : Tid .
    var TIDS : MSet{TidElt} .
    var AUS : Set{AuctionElt} .
    var MSG : Msg .
    var BMC : BidMsgContent .
    var TR : Timer .
    vars TIME TIME2 TIME3 : Time .
    var BS : Set{BidElt} .
    var TPT : TransporterTask .
    var WT : WorkerTask .
    var CONF : Configuration .
    vars COST : Cost .

    eq initiateAuction(< OID : Auctioneer | >, empty, CONF) = < OID : Auctioneer | > CONF .
    eq initiateAuction(< OID : Auctioneer | auctions : AUS >, TIDS, CONF) =
        < OID : Auctioneer | auctions  : (AUS, createAuction(TIDS)) >
        broadcastInRange(< OID : Auctioneer | >, tidToMsgContent(TIDS), CONF)  .

    ***No winner, so restart the auction.
    eq retryAuction(< OID : Auctioneer | >, CONF, [Task: TID TR | empty]) =
        initiateAuction(< OID : Auctioneer | >, TID, CONF) .
    ***we have a winner, so send to that winner.
    eq retryAuction(< OID : Auctioneer | auctions : AUS >, CONF, [Task: TID TR | BS]) =
        < OID : Auctioneer | auctions : ([Task: TID TR | BS], AUS) >
        broadcast(OID, won TID, auctionWinner(BS, "",cost(ratInf))) [owise] .

    ***Determines the winner of an auction when its timer runs out.
    crl [auctionTimerExpire] :
        < OID : Auctioneer | auctions : ([Task: TID TR | BS], AUS) >
        CONF
        =>
        retryAuction(< OID : Auctioneer | auctions : AUS >, 
            CONF, 
            [Task: TID TR | BS])
        CONF
        if expired(TR) .

    ***Adds bid to the auction
    rl [rcvBidMsg] :
        < OID : Auctioneer | auctions : ([Task: TID TR | BS], AUS) >
        msg bid COST on TID from OID2 to OID
        =>
        < OID : Auctioneer | auctions : ([Task: TID TR | ([OID2 bids COST], BS)], AUS) > .

    ***Close the auction when a winner has accepted the task.
    rl [rcvAcceptMsg] :
        < OID : Auctioneer | auctions : ([Task: TID TR | BS], AUS) >
        msg accept TID from OID2 to OID
        =>
        < OID : Auctioneer | auctions : AUS > .

    ***If the winner of the auction has become unable to complete the task, determine another winner or retry the auction.
    rl [rcvRejectMsg] :
        < OID : Auctioneer | auctions : ([Task: TID TR | ([OID2 bids COST], BS)], AUS) >
        CONF
        msg reject TID from OID2 to OID
        =>
        retryAuction(< OID : Auctioneer | auctions : AUS >, CONF, [Task: TID TR | BS])
        CONF .
endom
