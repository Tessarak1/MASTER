load time-inf .
load path-planner .
load message .
load map .
load field .
load obstacle .
load sites .
load auctioneer .
load entity .
load systemVars .
load representation .

omod ROBOT is 
    protecting AUCTIONEER .
    protecting MESSAGE .
    protecting OBSTACLE .
    protecting MAP .
    protecting TIME-INF .
    protecting FIELD .
    protecting PATH-PLANNER .
    protecting SITES .
    protecting ENTITY .
    protecting SYSTEM-VARS .
    protecting DIRECTION .
    protecting REPRESENTATION-SET .

    sort CargoLevel .
    sorts WorkerCargo TransporterCargo Cargo .
    sorts Seed Water Fertilizer Produce .
    sorts WorkState TimedWork .
    sorts YieldInfo YieldInfoSet .
    sorts BaseInfo BaseInfoSet WaitingInfo .
    sort PriorityState .

    subsorts Tid TimedWork < WorkState .

    subsort Seed Water Fertilizer < WorkerCargo .
    subsort Produce < TransporterCargo .
    subsort TransporterCargo WorkerCargo < Cargo .

    subsort YieldInfo < YieldInfoSet .
    subsort BaseInfo < BaseInfoSet .

    subsort PriorityState < MsgContent .

    class Robot |
        detectionRange : Rat,
        cargoLevel : CargoLevel,
        curCargo : Cargo,
        detected : Set{RepresentationElt},
        obsCoords : List-Coordinate,
        curTask : TaskStatus,
        workState : WorkState,
        negotiations : Set{NegotiationElt}, 
        yieldStatus : YieldInfoSet,
        waitingStatus : WaitingInfo .
    class Worker .
    class Transporter .
    
    subclass Worker Transporter < Robot < Entity Auctioneer .

    ops priorityIdle priorityTask priorityYielding priorityProtected : -> PriorityState [ctor] .
    op priorityState : Object -> PriorityState .

    op [_-_] : Oid Coordinate -> BaseInfo [ctor] .
    op noBaseInfo : -> BaseInfo [ctor] .
    op _,_ : BaseInfoSet BaseInfoSet -> BaseInfoSet [ctor assoc comm id: noBaseInfo] .
    op noWaitingInfo : -> WaitingInfo [ctor] .
    ***One timer to rescan, one longer to wipe.
    op [_|_|_] : BaseInfoSet Timer Timer -> WaitingInfo [ctor] .
    op getTimers : WaitingInfo -> MSet{TimerElt} .
    op decTimers : WaitingInfo Time -> WaitingInfo .
    op rescanWaitingOn : BaseInfoSet Configuration -> BaseInfoSet .
    op inDetectionRange : Object Configuration -> Configuration .
    op addWaiting : WaitingInfo Oid Coordinate -> WaitingInfo .

    ***When it has reached the given coordinate, the robot needs to notify Oid that it can stop yielding.
    op [Oid:_-_|_] : Oid Coordinate Timer -> YieldInfo [ctor] .
    ***Robot is waiting for another to have finished yielding
    op [Oid:_|_] : Oid Timer -> YieldInfo [ctor] .
    op noYieldInfo : -> YieldInfoSet [ctor] .    
    op _,_ : YieldInfoSet YieldInfoSet -> YieldInfoSet [ctor assoc comm id: noYieldInfo] .
    op addYieldInfo : Oid Coordinate YieldInfoSet -> YieldInfoSet .
    op addYieldInfo : Oid YieldInfoSet -> YieldInfoSet .
    op getYieldTimers : YieldInfoSet -> MSet{TimerElt} .
    op removeYieldInfo : Oid YieldInfoSet -> YieldInfoSet .
    op decTimers : YieldInfoSet Time -> YieldInfoSet .
    op yieldExpired : YieldInfo -> Bool .
    op getOid : YieldInfo -> Oid .

    op getPhysObjs : Configuration -> Configuration .

    op water : -> Water [ctor] .
    op fertilizer : -> Fertilizer [ctor] .
    op seed : -> Seed [ctor] .
    op produce : -> Produce [ctor] .

    op needNegotiation : Object Representation Object -> Bool .
    op startNegotiation : Object Representation Object -> Configuration .
    op $timeCheck : Object Oid Time -> Object .

    op calcBid : Object Tid Object -> RatInf .

    op detect : Configuration -> Configuration .
    op _detects_ : Object Object -> Bool .

    op remove : Oid Configuration -> Configuration .

    ops noWork : -> WorkState [ctor] .
    op [_,_,_] : Oid TaskType Time -> TimedWork [ctor] .
    ops emptyCargo full : -> CargoLevel [ctor] .
    op finishedResupply : Object TaskType -> Object .

    op getLocation : Object -> Coordinate .
    op getLocation : YieldInfo -> List-Coordinate .
    ops breaksPath $breaksPath : List-Coordinate Set{RepresentationElt} -> Bool .
    op canComplete : Object Tid -> Bool .
    op $parseTasksGL : Set{RepresentationElt} -> MSet{TidElt} .
    op parseTasksGL : Set{RepresentationElt} -> MSet{TidElt} .
    op assignTask : Object Tid -> Object .
    op prepareAuction : Object MSet{TidElt} -> Configuration .
    ops mustRejectTask : Object -> Bool .
    op startWorkGL : Object -> Object .
    op arrivedTask : Object Configuration -> Bool .

    ops $needResupply $needCSite : Object Tid -> Bool .
    ops resupplyCheck collectCheck : Object Tid Coordinate -> List-Coordinate .
    op $locChecks : Object Tid Configuration -> List-Coordinate .
    op $planPathLocs : Object Tid Configuration -> List-Coordinate .
    op $planPath : Object List-Coordinate List-Coordinate -> List-Coordinate .
    op decTimers : WorkState Time -> WorkState .

    ***Path that robot must traverse to be able to complete task.
    ***Travels to resupply and/or collection station if needed
    op planPath : Object Tid Object -> List-Coordinate .

    ***Adds the locations in the second list that are betweens locations in the first to the first list.
    op modifyPath : List-Coordinate List-Coordinate -> List-Coordinate .

    op closestPhysObjs : Coordinate Configuration Configuration -> Configuration .

    ***Checks if a given intersection has a connecting road that is not used by the list of locations.
    ***yieldLocation's boolean parameter determines if an intersection needs to have at least three connecting roads to be considered a valid solution.
    ***This is used for when a robot needs to yield to another yielding robot.
    op $yieldLocationHelper : Coordinate Set{RoadElt} -> Coordinate .
    op yieldLocation : Object Set{RoadElt} List-Coordinate -> List-Coordinate .
    ***Creates a path to the intersection that has a valid yieldLocation.
    op yieldIntersection : PQueue Object List-Coordinate Coordinate -> List-Coordinate .
    op yieldPath : Object Object List-Coordinate -> List-Coordinate .

    op conflictYieldIntersection : PQueue Object -> Object .
    op $conflictYieldPath : Configuration Object Coordinate -> List-Coordinate .
    op conflictYieldPath : Object Object -> List-Coordinate .
    op $conflictyieldAlgorithm : Object Object Oid List-Coordinate -> Configuration .
    op conflictyieldAlgorithm : Object Object Oid List-Coordinate -> Configuration .
    ***Takes in yieldPath to determine behavior based on if one was found or not.
    op $yieldAlgorithm : Object Object Oid List-Coordinate -> Configuration .
    ***Calculates yieldPath and sends result as argument to $yieldAlgorithm.
    op yieldAlgorithm : Object Object Oid List-Coordinate -> Configuration .
    ***Treats the coordinate as an obstacle, and calculates the additional distance required to complete the robot's task.
    op replanCost : Object Object Coordinate -> RatInf .

    op taskTypeMatch : Object TaskType -> Bool .

    ***Checks if the path represented by the second list is an immediate obstruction for the first.
    op pathConflict : List-Coordinate List-Coordinate -> Bool .

    var CARGO : Cargo .
    vars CONF CONF2 : Configuration .
    vars OID OID2 OID3 OID4 : Oid .
    var OIDS : Set{OidElt} .
    vars X Y X2 Y2 X3 Y3 X4 Y4 X5 Y5 : Rat .
    vars RI RI2 : RatInf .
    var N : Nat .
    var A : Area .
    vars LCO LCO2 LCO3 : List-Coordinate .
    vars L L2 : Level .
    var GS : GrowingState .
    var TC : TransporterCargo .
    var RS : Set{RoadElt} .
    var MC : MsgContent .
    var CID : Cid .
    var IS : Set{InfoElt} .
    vars D D2 : Direction .
    vars SP SP2 : Rat .
    var DR : Rat .
    var STATE : State .
    var REP : Representation .
    var REPS : Set{RepresentationElt} .
    vars OS OS2 : Set{OidElt} .
    vars TR TR2 : Timer .
    vars TIME TIME2 : Time .
    vars TID TID2 : Tid .
    var TIDS : MSet{TidElt} .
    vars AS AS2 : AttributeSet .
    var CL : CargoLevel .
    var PS : PriorityState .
    vars FUNC FUNC2 : FunctioningState .
    var INC : IncapacitatedState .
    var PQ : PQueue .
    var O : Object . 
    var NS : Set{NegotiationElt} .
    var COST : Cost .
    var BOOL : Bool .
    var YI : YieldInfo .
    var YIS : YieldInfoSet .

    vars TT TT2 : TaskType .
    var TTS : Set{TaskTypeElt} .
    var TS : TaskStatus .
    var TPT : TransporterTask .
    var WT : WorkerTask .
    var WS : WorkState .
    var TW : TimedWork .
    var B : Bid .    
    var AUS : Set{AuctionElt} .
    var BIS : BaseInfoSet .
    var WI : WaitingInfo .
    var TWS : TimedWorkState .

    eq calcBid(< OID : Robot | >, TID, < OID2 : Map | >) =
        pathLength(
            planPath(< OID : Robot | >, 
                TID, 
                < OID2 : Map | >
            )
        ) .
        
    ceq arrivedTask(< OID : Robot | coordinate : (X,Y),
                curTask : [OID2, fixAt (X2,Y2)] >, CONF)
        =
        true if distance((X,Y), (X2,Y2)) <= ROBOT-SIZE .

    eq arrivedTask(< OID : Robot | coordinate : (X,Y),
                curTask : [OID2, unloadTask] >,
            < OID2 : CollectionSite | coordinate : (X,Y) >
            CONF)
        =
        true .
    eq arrivedTask(< OID : Robot | coordinate : (X,Y),
                curTask : [OID2, resupplyTask] >,
            < OID2 : ResupplySite | coordinate : (X,Y) >
            CONF)
        =
        true .

    eq arrivedTask(< OID : Robot | coordinate : (X,Y),
                curTask : [OID2, TT] >,
            < OID2 : Field | coordinate : (X,Y) >    
            CONF
        )
        = true .
    
    eq arrivedTask(< OID : Robot | >, CONF) = false [owise] .
    ***resupply
    ***unload
    ***GL task.

    eq getPhysObjs(< OID : Robot | > CONF) = < OID : Robot | > getPhysObjs(CONF) .
    eq getPhysObjs(CONF) = none [owise] .

    eq addWaiting(noWaitingInfo, OID, (X,Y)) = [[OID - (X,Y)] | RESCAN-TIMER | WAITING-TIMER] .
    eq addWaiting([BIS | TR | TR2], OID, (X,Y)) = [BIS , [OID - (X,Y)] | TR | reset(TR2)] .
    eq getTimers(noWaitingInfo) = empty .
    eq getTimers([BIS | TR | TR2]) = TR TR2 .
    eq decTimers(noWaitingInfo, TIME) = noWaitingInfo .
    eq decTimers([BIS | TR | TR2], TIME) = [BIS | dec(TR, TIME) | dec(TR2, TIME)] .
    ***If a robot has moved from the last registered coordinate or moved out of detection range it is removed from waiting on.
    eq rescanWaitingOn(([OID - (X,Y)] , BIS), < OID : Robot | coordinate : (X,Y) > CONF) = [OID - (X,Y)] , rescanWaitingOn(BIS, CONF) .
    eq rescanWaitingOn(BIS, CONF) = noBaseInfo [owise] .
    eq [noBaseInfo | TR | TR2] = noWaitingInfo .

    eq getTimers(< OID : Robot | auctions : AUS, yieldStatus : YIS, waitingStatus : WI >) =
        getTimers(AUS) getYieldTimers(YIS) getTimers(WI) .

    eq priorityState(< OID : Robot | state : TWS, workState : TW >) = priorityProtected .
    eq priorityState(< OID : Robot | state : waiting, waitingStatus : [BIS | TR | TR2] >) = priorityProtected .
    ceq priorityState(< OID : Robot | state : negotiating, negotiations : NS >) = priorityProtected if NS =/= empty .
    eq priorityState(< OID : Robot | state : idle, curTask : noTask, yieldStatus : noYieldInfo >) = priorityIdle .
    ceq priorityState(< OID : Robot | state : FUNC, yieldStatus : YIS >) = priorityYielding if YIS =/= noYieldInfo [owise] .
    eq priorityState(< OID : Robot | state : FUNC, curTask : TID, yieldStatus : noYieldInfo >) = priorityTask [owise] .
    

    eq taskTypeMatch(< OID : Worker | >, WT) = true .
    eq taskTypeMatch(< OID : Transporter | >, TPT) = true .
    eq taskTypeMatch(< OID : Robot | >, TT) = false [owise] .

    eq remove(OID, < OID : Robot | > CONF) = CONF .
    eq remove(OID, CONF) = CONF [owise] .

    eq yieldExpired([Oid: OID - (X,Y) | TR]) = expired(TR) .
    eq yieldExpired([Oid: OID | TR]) = expired(TR) .

    eq finishedResupply(< OID : Worker | state : resupplying, curCargo : CARGO >, wateringTask) = < OID : Worker | curCargo : water, cargoLevel : full, state : idle > .
    eq finishedResupply(< OID : Worker | state : resupplying, curCargo : CARGO >, fertilizeTask) = < OID : Worker | curCargo : fertilizer, cargoLevel : full, state : idle > .
    eq finishedResupply(< OID : Worker | state : resupplying, curCargo : CARGO >, plantTask) = < OID : Worker | curCargo : seed, cargoLevel : full, state : idle > .
    eq finishedResupply(< OID : Worker | >, TT) = < OID : Worker | > [owise] .

    ***There is a path conflict if the paths share an intersection from different direction
    ***or if they are headed directly towards one another.
    ceq pathConflict((X,Y) (X2,Y2) LCO, (X3,Y3) (X2,Y2) LCO2) = 
        true if setDirection((X,Y),(X2,Y2)) =/= setDirection((X3,Y3), (X2,Y2)) . 
    ceq pathConflict((X,Y) (X2,Y2) LCO, (X3,Y3) (X4,Y4) LCO2) = true if
        overlap((X,Y) (X2,Y2), (X3,Y3) (X4,Y4)) and oppositeDirections(setDirection((X,Y), (X2,Y2)), setDirection((X3,Y3), (X4,Y4))) .
    eq pathConflict(LCO, (X,Y)) = findPathPair((X,Y), LCO) =/= nil .
    eq pathConflict(LCO, LCO2) = false [owise] .

    eq inDetectionRange(< OID : Robot | coordinate : (X,Y), detectionRange : DR >, < OID2 : Locatable | coordinate : (X2, Y2) > CONF) =
        < OID2 : Locatable | > inDetectionRange(< OID : Robot | >, CONF) .
    eq inDetectionRange(< OID : Robot | >, CONF) = none [owise] .

    ***Calculates the cost of replanning a path
    eq replanCost(< OID : Robot | curTask : TID, obsCoords : LCO >, < OID2 : Map | >, (X,Y)) =
        if pathLength(planPath(< OID : Robot | obsCoords : LCO (X,Y) >, TID, < OID2 : Map | >)) == ratInf
        then
            ratInf
        else
            pathLength(planPath(< OID : Robot | obsCoords : LCO (X,Y) >, TID, < OID2 : Map | >))
            -
            pathLength(planPath(< OID : Robot | obsCoords : remove(LCO, (X,Y)) >, TID, < OID2 : Map | >))
        fi .

    eq $timeCheck(< OID : Robot | >, OID2, TIME) =
        if TIME < EMERGENCY-TIME
        then
            < OID : Robot | state : idle, speed : 0 >
        else
            if TIME < SAFE-TIME 
            then
                < OID : Robot | speed : SAFE-SPEED >
            else
                < OID : Robot | >
            fi
        fi .

    ***Need to start negotation if two robots move towards each other directly, without any intersection in the middle.
    ceq needNegotiation(< OID : Robot | coordinate : (X,Y), direction : D, state : moving, negotiations : NS >,
        {OID2 : Robot | (X2,Y2) , D2 , moving , IS}, < OID3 : Map | roads : RS >) =
        true
        if oppositeDirections(D, D2)
           and (findRoad((X,Y), RS) == findRoad((X2,Y2), RS))
           and not inNegotiationSet(NS, OID2) .

    ***If a robot is moving towards a stationary robot that is in the way.
    ceq needNegotiation(< OID : Robot | coordinate : (X,Y), remainingPath : LCO, state : moving, negotiations : NS >,
        {OID2 : Robot | (X2,Y2) , STATE , IS}, < OID3 : Map | roads : RS >) =
        true
        if (STATE =/= moving)
           and (findPathPair((X2,Y2), (X,Y) LCO) =/= nil)
           and not inNegotiationSet(NS, OID2) .

    ***two robots move towards the same intersection from different paths.
    ceq needNegotiation(< OID : Robot | coordinate : (X,Y), 
                state : moving, 
                direction : D, 
                negotiations : NS >,
            {OID2 : Robot | (X2,Y2) , D2 , moving , IS}, 
            < OID3 : Map | roads : ({(X3,Y3) (X4,Y4)} , {(X4, Y4) (X5,Y5)} , RS) >) 
        =
        true
        if findRoad((X,Y), {(X3,Y3) (X4,Y4)}) =/= empty
           and findRoad((X2,Y2), {(X4, Y4) (X5,Y5)}) =/= empty
           and setDirection((X,Y), (X4,Y4)) == D
           and setDirection((X2,Y2), (X4,Y4)) == D2
           and not inNegotiationSet(NS, OID2) .
    eq needNegotiation(< OID : Robot | >, {OID2 : Robot | IS}, < OID3 : Map | >) = false [owise] .

    eq startNegotiation(< OID : Robot | coordinate : (X,Y), remainingPath : LCO, negotiations : NS >, {OID2 : Robot | (X2,Y2) , IS}, < OID3 : Map | >) =
        < OID : Robot | state : negotiating, speed : 0, negotiations : addNegotiation(NS, [OID2 | (X2,Y2) | noCost]) > 
        unicast(OID, requestPath & path((X,Y) LCO) & priorityState(< OID : Robot | >), OID2) .

    eq closestPhysObjs((X,Y), CONF, none) = CONF .
    eq closestPhysObjs((X,Y), < OID : Robot | coordinate : (X2,Y2), direction : D > CONF, < OID2 : Robot | coordinate : (X3,Y3), direction : D > CONF2) =
        if distance((X,Y), (X2,Y2)) < distance((X,Y), (X3,Y3))
        then
            closestPhysObjs((X,Y), < OID : Robot | > CONF, CONF2)
        else
            closestPhysObjs((X,Y), < OID2 : Robot | > CONF, CONF2)
        fi .
    eq closestPhysObjs((X,Y), CONF, < OID : Robot | > CONF2) = closestPhysObjs((X,Y), < OID : Robot | > CONF, CONF2) .
    
    eq getLocation(< OID : Robot | coordinate : (X,Y) >) = (X,Y) .
    eq getLocation([Oid: OID - (X,Y) | TR]) = (X,Y) .
    eq getLocation(YI) = nil [owise] .

    eq getYieldTimers(([Oid: OID - (X,Y) | TR] , YIS)) = TR getYieldTimers(YIS) .
    eq getYieldTimers(([Oid: OID | TR] , YIS)) = TR getYieldTimers(YIS) .
    eq getYieldTimers(noYieldInfo) = empty .

    eq decTimers(([Oid: OID - (X,Y) | TR] , YIS), TIME) = [Oid: OID - (X,Y) | dec(TR, TIME)] , decTimers(YIS, TIME) .
    eq decTimers(([Oid: OID | TR] , YIS), TIME) = [Oid: OID | dec(TR, TIME)] , decTimers(YIS, TIME) .
    eq decTimers(noYieldInfo, TIME) = noYieldInfo .

    eq decTimers([OID2, TT, TIME], TIME2) = [OID2, TT, (TIME monus TIME2)] .
    eq decTimers(WS, TIME) = WS [owise] .

    eq decTimers(
            < OID : Robot |
                auctions : AUS,
                yieldStatus : YIS,
                waitingStatus : WI,
                workState : WS
                >, 
            TIME)
        =
        < OID : Robot |
            auctions : decTimers(AUS, TIME),
            yieldStatus : decTimers(YIS, TIME),
            waitingStatus : decTimers(WI, TIME),
            workState : decTimers(WS, TIME)
        > .

    eq mustRejectTask(< OID : Robot | state : INC >) = true .
    eq mustRejectTask(< OID : Robot | curTask : TID >) = true .
    eq mustRejectTask(< OID : Robot | >) = false [owise] .

    eq $needCSite(< OID : Worker | >, TID) = false .
    eq $needCSite(< OID : Transporter | cargoLevel : CL >, TID) = CL == full .

    ceq removeYieldInfo(OID, (YI ,YIS)) = YIS if getOid(YI) == OID .
    eq removeYieldInfo(OID, YIS) = YIS [owise] .

    ceq $needResupply(< OID : Worker | curCargo : CARGO >, [OID2, wateringTask]) = true if CARGO =/= water .
    ceq $needResupply(< OID : Worker | curCargo : CARGO >, [OID2, fertilizeTask]) = true if CARGO =/= fertilizer .
    ceq $needResupply(< OID : Worker | curCargo : CARGO >, [OID2, plantTask]) = true if CARGO =/= seed .
    eq $needResupply(< OID : Worker | cargoLevel : emptyCargo >, TID) = true .
    eq $needResupply(< OID : Robot | >, TID) = false [owise] .

    eq collectCheck(< OID : Robot | >, TID, (X,Y)) = if $needCSite(< OID : Robot | >, TID) then (X,Y) else nil fi .

    eq resupplyCheck(< OID : Robot | >, TID, (X,Y)) = if $needResupply(< OID : Robot | >, TID) then (X,Y) else nil fi .

    eq $locChecks(< OID : Robot | >, TID, < OID2 : ResupplySite | coordinate : (X,Y) > < OID3 : CollectionSite | coordinate : (X2,Y2) > CONF) =
        resupplyCheck(< OID : Robot | >, TID, (X,Y)) collectCheck(< OID : Robot | >, TID, (X2,Y2)) .

    ***Turn the conditional into an operation?
    ceq canComplete(< OID : Worker | state : FUNC, curTask : TS >, [OID2, fixAt (X,Y)]) = true if (TS == noTask) or (TS == [OID2, fixAt (X,Y)]) .
    ceq canComplete(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : water, curTask : TS >, [OID2, wateringTask]) = true if (TS == noTask) or (TS == [OID2, wateringTask]) .
    ceq canComplete(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : fertilizer, curTask : TS >, [OID2, fertilizeTask]) = true if (TS == noTask) or (TS == [OID2, fertilizeTask]) .
    ceq canComplete(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : seed, curTask : TS >, [OID2, plantTask]) = true if (TS == noTask) or (TS == [OID2, plantTask]) .
    ceq canComplete(< OID : Transporter | state : FUNC, cargoLevel : emptyCargo, curTask : TS >, [OID2, harvestTask]) = true if (TS == noTask) or (TS == [OID2, harvestTask]) .
    ceq canComplete(< OID : Transporter | state : FUNC, cargoLevel : full, curTask : TS >, [OID2, unloadTask]) = true if (TS == noTask) or (TS == [OID2, unloadTask]) .
    ceq canComplete(< OID : Robot | curTask : TID >, TID2) = false if TID =/= noTask .
    eq canComplete(< OID : Robot | >, TID) = false [owise] .


    ***Returns the locations the robot must visit on its path to complete the task.
    eq $planPathLocs(< OID : Robot | coordinate : (X,Y) >, [OID2, TT], < OID2 : Locatable | coordinate : (X2,Y2) > CONF) =
        (X,Y) $locChecks(< OID : Robot | >, [OID2, TT], < OID2 : Locatable | coordinate : (X2,Y2) > CONF) (X2,Y2) .

    ***LCO2 is obstructions
    eq $planPath(< OID : Map | >, LCO, LCO2) = dijkstraChain(getIntersections(modifyMap(< OID : Map | >, LCO, LCO2)), LCO) .

    eq planPath(< OID : Robot | coordinate : (X,Y), obsCoords : LCO >, [OID2, fixAt (X2,Y2)], < OID3 : Map | intersections : CONF >) =
        shortenEndBy(
            rmvNeighborDuplicates($planPath(< OID3 : Map | >, (X,Y) (X2,Y2), LCO)), ROBOT-SIZE) .

    eq planPath(< OID : Robot | obsCoords : LCO >, [OID2, TT], < OID3 : Map | intersections : CONF >) =
        rmvNeighborDuplicates(
            $planPath(
                < OID3 : Map | >,
                $planPathLocs(< OID : Robot | >, [OID2, TT], CONF),
                LCO
            )
        ) [owise] .

    ceq modifyPath(LCO (X,Y) (X2,Y2) LCO2, (X3,Y3) LCO3) = modifyPath(LCO (X,Y) (X3,Y3) (X2,Y2) LCO2, LCO3)
        if ((X3,Y3) =/= (X,Y) and (X3,Y3) =/= (X2,Y2) and findPathPair((X3,Y3), (X,Y) (X2,Y2)) =/= nil) . 
    eq modifyPath(LCO, LCO2) = LCO [owise] .
    
    ***Todo this can be generalized with the road thingy
    ceq $breaksPath((X,Y) (X,Y2), {OID2 : CID | (X,Y3) , north , IS}) = true if Y > Y2 .
    ceq $breaksPath((X,Y) (X2,Y), {OID2 : CID | (X3,Y) , east , IS}) = true if X > X2 .
    ceq $breaksPath((X,Y) (X,Y2), {OID2 : CID | (X,Y3) , south , IS}) = true if Y < Y2 .
    ceq $breaksPath((X,Y) (X2,Y), {OID2 : CID | (X3,Y) , west , IS}) = true if X < X2 .
    eq $breaksPath(LCO, REPS) = false [owise] .
    
    ceq breaksPath(LCO, {OID2 : CID | (X,Y) , IS}) = false if findPathPair((X,Y), LCO) == nil .
    eq breaksPath(LCO, {OID2 : Obstacle | (X,Y) , IS}) =
        if findPathPair((X,Y), LCO) == nil then
            false
        else
            true
        fi .
    eq breaksPath(LCO, {OID2 : CID | (X,Y) , D , IS}) = $breaksPath(findPathPair((X,Y), LCO), {OID2 : CID | (X,Y) , D , IS}) .

    eq $yieldLocationHelper((X,Y), ({(X,Y) (X,Y2)} , RS)) =
        if Y < Y2
        then
            (X, Y + YIELD-GAP)
        else
            (X, Y - YIELD-GAP)
        fi .
    eq $yieldLocationHelper((X,Y), ({(X,Y) (X2,Y)} , RS)) =
        if X < X2
        then
            (X + YIELD-GAP, Y)
        else
            (X - YIELD-GAP, Y)
        fi .

    eq yieldLocation(< OID : PassIntersection | coordinate : (X,Y) >, RS, LCO (X,Y) LCO2) =
        if findRoad((X,Y), RS) \ findRoad(last(LCO) first(LCO2), RS) =/= empty  then
            $yieldLocationHelper((X,Y), findRoad((X,Y), RS) \ findRoad(last(LCO) first(LCO2), RS))
        else
            nil
        fi .
    eq yieldLocation(< OID : Intersection | >, RS, LCO) = nil [owise] .
        
    eq yieldIntersection([< OID : PassIntersection | coordinate : (X,Y) >, 0, "Start"] PQ, < OID2 : Map | roads : RS >, LCO, (X,Y)) = 
        if yieldLocation(< OID : PassIntersection | >, RS, LCO) =/= nil
        then
            yieldLocation(< OID : PassIntersection | >, RS, LCO)
        else
            if | findRoad((X,Y), RS) | == 1
            then
                nil
            else
                yieldIntersection(PQ, < OID2 : Map | >, LCO, (X,Y))
            fi
        fi .
    ceq yieldIntersection([< OID : PassIntersection | coordinate : (X,Y) >, RI, OID2] PQ, < OID3 : Map | intersections : CONF, roads : RS >, LCO, (X2,Y2)) =
        if RI == ratInf
        then
            nil
        else
            if yieldLocation(< OID : PassIntersection | >, RS, LCO) =/= nil
            then
                if not pathConflict(dijkstraSearch(CONF, (X2,Y2), (X,Y)), LCO)
                then
                    dijkstraSearch(CONF, (X2,Y2), (X,Y)) yieldLocation(< OID : PassIntersection | >, RS, LCO)
                else
                    yieldIntersection(PQ, < OID3 : Map | >, LCO, (X2,Y2))
                fi
            else
                yieldIntersection(PQ, < OID3 : Map | >, LCO, (X2,Y2))
            fi
        fi
        if OID2 =/= "Start" .
    eq yieldIntersection(noQueue, < OID : Map | >, LCO, (X,Y)) = nil .

    eq yieldPath(< OID : Robot | coordinate : (X,Y), obsCoords : LCO >, < OID2 : Map | >, LCO2) =
        yieldIntersection(
            updateDistances(PQConvert(getIntersections(modifyMap(< OID2 : Map | >, (X,Y) LCO2, LCO)), (X,Y))),
            modifyMap(< OID2 : Map | >, (X,Y) LCO2, LCO),
            modifyPath(LCO2, (X,Y)),
            (X,Y)
        ) .

    ***valid yieldIntersection has at least 3 connected roads.
    eq conflictYieldIntersection([< OID : PassIntersection | coordinate : (X,Y) >, RI, OID2] PQ, < OID3 : Map | roads : RS >) =
        if RI == ratInf
        then
            none
        else
            if | findRoad((X,Y), RS) | > 2
            then
                < OID : PassIntersection | >
            else
                conflictYieldIntersection(PQ, < OID3 : Map | >)
            fi
        fi .
        
    eq $conflictYieldPath(< OID : PassIntersection | coordinate : (X,Y) >, < OID2 : Map | intersections : CONF, roads : RS >, (X2,Y2)) =
        dijkstraSearch(CONF, (X2,Y2), (X,Y)) yieldLocation(< OID : PassIntersection | >, RS, dijkstraSearch(CONF, (X2,Y2), (X,Y))) .

    eq $conflictYieldPath(none, < OID2 : Map | >, (X2,Y2)) = nil .

    eq conflictYieldPath(< OID : Robot | coordinate : (X,Y), obsCoords : LCO >, < OID2 : Map | >) =
        $conflictYieldPath(
            conflictYieldIntersection(
                updateDistances(PQConvert(getIntersections(modifyMap(< OID2 : Map | >, (X,Y), LCO)), (X,Y))),
                modifyMap(< OID2 : Map | >, (X,Y), LCO)
            ),
            modifyMap(< OID2 : Map | >, (X,Y), LCO),
            (X,Y)
        ) .

    ***TODO: instead of setting path directly, planPath with another path?
    ***No yieldpath is found, do conflictyieldpath instead
    eq $yieldAlgorithm(< OID : Robot | >, < OID2 : Map | >, OID3, nil) =
        < OID : Robot | remainingPath : conflictYieldPath(< OID : Robot | >, < OID2 : Map | >) >
        unicast(OID, conflictYield(conflictYieldPath(< OID : Robot | >, < OID2 : Map | >)), OID3) .

    ***If a yieldpath is found, yield to it and say so.
    eq $yieldAlgorithm(< OID : Robot | negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, LCO (X,Y) (X2,Y2)) =
        < OID : Robot | remainingPath : LCO (X,Y) (X2,Y2), negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInfo(OID3, YIS) >
        unicast(OID, yielding (X,Y), OID3) .

    ***one step to yield path, set it as rem path.
    eq $yieldAlgorithm(< OID : Robot | coordinate : (X,Y), negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, (X2,Y2)) =
        < OID : Robot | remainingPath : (X2,Y2), negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInfo(OID3, YIS) >
        unicast(OID, yielding (X,Y), OID3) .

    eq $conflictyieldAlgorithm(< OID : Robot | state : STATE, negotiations : NS >, < OID2 : Map | >, OID3, nil) =
        < OID : Robot | state : deadlocked, negotiations : endNegotiation(NS, OID3) >
        unicast(OID, noYield, OID3) .
    
    eq $conflictyieldAlgorithm(< OID : Robot | negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, LCO (X,Y) (X2,Y2)) =
        < OID : Robot | remainingPath : LCO (X,Y) (X2,Y2), negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInfo(OID3, YIS) >
        unicast(OID, yielding (X,Y), OID3) .

    eq conflictyieldAlgorithm(< OID : Robot | coordinate : (X,Y) >, < OID2 : Map | >, OID3, LCO) =
        $conflictyieldAlgorithm(< OID : Robot | >, < OID2 : Map | >, OID3, yieldPath(< OID : Robot | >, < OID2 : Map | >, LCO)) .

    ***Robot moves out of way of LCO.
    eq yieldAlgorithm(< OID : Robot | coordinate : (X,Y), remainingPath : LCO, negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, LCO2) =
        if not pathConflict((LCO2), (X,Y))
        then
            < OID : Robot | remainingPath : nil, negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInfo(OID3, YIS) >
            unicast(OID, yielding sharedLocation((X,Y) LCO, LCO2), OID3)
        else
            $yieldAlgorithm(< OID : Robot | >, < OID2 : Map | >, OID3, yieldPath(< OID : Robot | >, < OID2 : Map | >, LCO2))
        fi .

    eq addYieldInfo(OID, (X,Y), ([Oid: OID - (X2,Y2) | TR] , YIS)) =
        [Oid: OID - (X,Y) | YIELD-TIMER] , YIS .
    eq addYieldInfo(OID, (X,Y), YIS) =
        [Oid: OID - (X,Y) | YIELD-TIMER] , YIS [owise] .
    eq addYieldInfo(OID, ([Oid: OID | TR] ,YIS)) = 
        [Oid: OID | YIELD-TIMER] , YIS .
    eq addYieldInfo(OID, YIS) =
        [Oid: OID | YIELD-TIMER] , YIS [owise] .

    eq getOid([Oid: OID - (X,Y) | TR]) = OID .
    eq getOid([Oid: OID | TR]) = OID .

    ceq < OID : Robot | coordinate : (X,Y), detected : REPS, detectionRange : DR > 
        detects 
        < OID2 : Locatable | coordinate : (X2,Y2) > 
        =
        true if (not OID2 in REPS) and (distance((X,Y), (X2,Y2)) <= DR) .
    eq < OID : Robot | > detects < OID2 : Locatable | > = false [owise] .

    ceq detect(
            < OID : Robot | state : FUNC, detected : REPS >
            < OID2 : Obstacle | coordinate : (X2, Y2) > CONF
        ) 
        =
        detect(
            < OID : Robot | detected : ({OID2 : Obstacle | (X2, Y2)} , REPS) >
            < OID2 : Obstacle | > CONF
        )
        if < OID : Robot | > detects < OID2 : Obstacle | > .

    ceq detect(
            < OID : Robot | detected : REPS >
            < OID2 : Robot | state : STATE, coordinate : (X2, Y2), direction : D, speed : SP >
        CONF
        )
        =
        detect(
            < OID : Robot | detected : ({OID2 : Robot | (X2, Y2) , D , detectedSpeed(SP) , STATE} , REPS) >
            < OID2 : Robot | > CONF
        )
        if (< OID : Robot | > detects < OID2 : Robot | >) .
    eq detect(CONF) = CONF [owise] .

    crl [rescanTimerExpire] :
        {< OID : Robot | waitingStatus : [BIS | TR | TR2] >
        CONF}
        =>
        {< OID : Robot | waitingStatus : [rescanWaitingOn(BIS, inDetectionRange(< OID : Robot | >, CONF)) | reset(TR) | TR2] >
        CONF}
        if expired(TR) .
    
    crl [waitingTimerExpire] :
        < OID : Robot | waitingStatus : [BIS | TR | TR2] >
        =>
        < OID : Robot | waitingStatus : noWaitingInfo >
        if expired(TR2) .
    
    crl [rcvPriorityProtectedMsg] :
        < OID : Robot | coordinate : (X,Y), remainingPath : LCO, waitingStatus : WI, negotiations : NS >
        msg priorityProtected & path((X2,Y2) LCO2) from OID2 to OID
        =>
        < OID : Robot | waitingStatus : addWaiting(WI, OID2, (X2,Y2)), negotiations : endNegotiation(NS, OID2) >
        if pathConflict((X,Y) LCO, (X2,Y2)) .

    crl [yieldTimerExpire] :
        < OID : Robot | yieldStatus : YI , YIS >
        =>
        < OID : Robot | yieldStatus : YIS >
        if yieldExpired(YI) .

    rl [finishWaiting] : 
        < OID : Robot | state : waiting, waitingStatus : noWaitingInfo, negotiations : NS >
        =>
        if NS == empty
        then
            < OID : Robot | state : idle >
        else
            < OID : Robot | state : negotiating >
        fi .
        
    rl [rcvWonMsg] :
        < OID : Robot | >
        msg won TID from OID2 to OID
        =>
        < OID : Robot | state : planningPath, speed : 0, curTask : TID > .
    
    crl [restartTask] :
        {< OID : Robot | state : idle, remainingPath : nil, yieldStatus : noYieldInfo, curTask : TID, workState : noWork >
        CONF}
        =>
        {< OID : Robot | state : planningPath >
        CONF}
        if not arrivedTask(< OID : Robot | >, CONF) .

    ***In all cost rules, implement support if no cost has been calculated yet
    crl [rcvHigherCostMsg] :
        < OID : Robot | state : FUNC, 
            obsCoords : LCO, 
            negotiations : (NS , [OID2 | (X,Y) | cost(RI)]), 
            curTask : TID >
        < OID3 : Map | >
        msg path((X2,Y2) LCO2) & pathCost(cost(RI2)) from OID2 to OID
        =>
        < OID : Robot | state : planningPath, 
            obsCoords : (X2,Y2) LCO, 
            negotiations : NS >
        < OID3 : Map | >
        unicast(OID, noConflict, OID2) 
        if RI2 > RI .

    rl [rcvEqualCostMsg] :
        < OID : Robot | state : FUNC, 
            obsCoords : LCO, 
            negotiations : (NS , 
                [OID2 | (X,Y) | cost(RI)]), 
            curTask : TID >
        < OID3 : Map | > 
        msg path((X2,Y2) LCO2) 
            & pathCost(cost(RI)) from OID2 to OID
        =>
        < OID3 : Map | > 
        if RI == ratInf
        then
            if OID < OID2
            then
                yieldAlgorithm(
                    < OID : Robot | state : negotiating, 
                        speed : 0, 
                        negotiations : addNegotiation(NS, 
                            [OID2 | (X2,Y2) | cost(RI)]) >,
                    < OID3 : Map | >,
                    OID2,
                    (X2,Y2) LCO2
                )
            else
                < OID : Robot | >
            fi
        else
            if OID < OID2
            then
                < OID : Robot | state : planningPath, 
                    obsCoords : (X2,Y2) LCO, 
                    negotiations : NS >
                unicast(OID, noConflict, OID2)
            else
                < OID : Robot | >
            fi 
        fi .

    crl [rcvLowerCostMsg] :
        < OID : Robot | negotiations : (NS , 
            [OID2 | (X,Y) | cost(RI)]) >
        msg path(LCO) & pathCost(cost(RI2)) from OID2 to OID
        =>
        < OID : Robot | >
        if RI < RI2  .

    crl [rcvInvalidCost] :
        < OID : Robot | negotiations : NS >
        msg path(LCO) & pathCost(COST) from OID2 to OID
        =>
        < OID : Robot | >
        if not inNegotiationSet(NS, OID2) .
        
    rl [rcvNoConflictMsg] :
        < OID : Robot | negotiations : NS >
        msg noConflict from OID2 to OID
        =>
        < OID : Robot | negotiations : endNegotiation(NS, OID2) > .

    rl [rcvYieldingMsg] :
        < OID : Robot | negotiations : NS, yieldStatus : YIS >
        msg yielding (X,Y) from OID2 to OID
        =>
        < OID : Robot | negotiations : endNegotiation(NS, OID2), yieldStatus : addYieldInfo(OID2, (X,Y), YIS) > .

    crl [rcvConflictYieldHigherPriority] :
        < OID : Robot | coordinate : (X,Y), remainingPath : LCO, state : negotiating, negotiations : NS >
        msg conflictYield(LCO2) from OID2 to OID
        =>
        < OID : Robot | negotiations : endNegotiation(NS, OID2) >
        unicast(OID, priorityProtected & path((X,Y) LCO), OID2)
        if priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID2) >) == priorityProtected .
    
    crl [rcvConflictYield] :
        < OID : Robot | state : negotiating, negotiations : NS >
        < OID2 : Map | >
        msg conflictYield(LCO2) from OID3 to OID
        =>
        conflictyieldAlgorithm(< OID : Robot | >, < OID2 : Map | >, OID3, LCO2)
        < OID2 : Map | >
        if priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID3) >) =/= priorityProtected .

    rl [rcvNoYieldMsg] :
        < OID : Robot | negotiations : NS >
        msg noYield from OID2 to OID
        =>
        < OID : Robot | state : deadlocked, negotiations : endNegotiation(NS, OID2) > .

    rl [planPath] :
        < OID : Robot | state : planningPath, 
            detected : empty, 
            curTask : TID >
        < OID2 : Map | >
        =>
        < OID : Robot | state : idle, 
            remainingPath : planPath(< OID : Robot | >, 
                    TID, 
                    < OID2 : Map | >) >
        < OID2 : Map | > .
    ***Notify another robot when Self has reached the yieldIntersection, Other can move again.
    rl [finishYieldingTask] :
        < OID : Robot | coordinate : (X,Y), yieldStatus : ([Oid: OID2 - (X,Y) | TR], YIS) >
        =>
        < OID : Robot | yieldStatus : YIS >
        unicast(OID, completedYield, OID2) .

    ***Other has requested a check for potential pathconflict. Return noConflict if either paths dont intersect, or unmoving
    crl [rcvPathNegotiationNoConflict] :
        < OID : Robot | coordinate : (X,Y), remainingPath : LCO >
        msg requestPath & path(LCO2) & PS from OID2 to OID
        =>
        < OID : Robot | >
        unicast(OID, noConflict, OID2)
        if (not pathConflict(LCO2, (X,Y) LCO)) .

    crl [rcvPathNegotiationIdle] :
        < OID : Robot | coordinate : (X,Y), negotiations : NS >
        < OID2 : Map | >
        msg requestPath & path((X2,Y2) LCO) & PS from OID3 to OID
        =>
        yieldAlgorithm(
            < OID : Robot | state : negotiating, negotiations : addNegotiation(NS, [OID3 | (X2,Y2) | noCost]) >,
            < OID2 : Map | >,
            OID3,
            (X2,Y2) LCO
        )
        < OID2 : Map | >
        if pathConflict((X2,Y2) LCO, (X,Y)) and priorityState(< OID : Robot | >) == priorityIdle .

    crl [rcvPathNegotiationProtected] :
        < OID : Robot | coordinate : (X,Y), remainingPath : LCO, negotiations : NS >
        msg requestPath & path(LCO2) & PS from OID2 to OID
        =>
        < OID : Robot | >
        unicast(OID, path((X,Y) LCO) & priorityProtected, OID2)
        if pathConflict(LCO2, (X,Y)) 
        and priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID2) >) 
            == priorityProtected .

    crl [rcvPathNegotiationTaskYield] :
        < OID : Robot | coordinate : (X,Y), remainingPath : LCO, negotiations : NS >
        < OID2 : Map | >
        msg requestPath & path((X2,Y2) LCO2) & PS from OID3 to OID
        =>
        < OID2 : Map | >
        yieldAlgorithm(
            < OID : Robot | state : negotiating, 
                speed : 0, 
                negotiations : addNegotiation(NS, 
                        [OID3 | (X2,Y2) | noCost]) >,
            < OID2 : Map | >,
            OID3,
            (X2,Y2) LCO2
        )
        if pathConflict((X2,Y2) LCO2, (X,Y) LCO)
        and PS =/= priorityTask 
        and priorityState(< OID : Robot | 
                    negotiations : endNegotiation(NS, OID3) >) 
            ==
            priorityTask .

    crl [rcvPathNegotiationReplan] :
        < OID : Robot | coordinate : (X,Y), 
            remainingPath : LCO, 
            negotiations : NS >
        < OID2 : Map | >
        msg requestPath 
            & path((X2,Y2) LCO2) 
            & PS from OID3 to OID
        =>
        < OID2 : Map | >
        < OID : Robot | state : negotiating, 
            speed : 0, 
            negotiations : addNegotiation(NS, 
                    [OID3 | (X2,Y2) | 
                        cost(
                            replanCost(
                                < OID : Robot | >, 
                                < OID2 : Map | >, 
                                (X2, Y2)))]) >
        unicast(OID, path((X,Y) LCO) & 
            pathCost(cost(
                replanCost(
                    < OID : Robot | >, 
                    < OID2 : Map | >, 
                    (X2, Y2)))), 
            OID3)
        if pathConflict((X2,Y2) LCO2, (X,Y) LCO)
        and PS == priorityTask 
        and priorityState(< OID : Robot | 
                    negotiations : endNegotiation(NS, OID3) >) 
            ==
            priorityTask .

    crl [rcvPathNegotiationYielding] : 
        < OID : Robot | coordinate : (X,Y), 
            remainingPath : LCO, 
            negotiations : NS >
        < OID2 : Map | >
        msg requestPath 
            & path((X2,Y2) LCO2)
            & PS from OID3 to OID
        =>
        < OID2 : Map | >
        < OID : Robot | >
        unicast(OID, requestPath & path(LCO) & priorityYielding, OID3)
        if priorityState(< OID : Robot | 
            negotiations : endNegotiation(NS, OID3) >) 
                == priorityYielding
            and PS =/= priorityYielding
            and pathConflict((X2,Y2) LCO2, (X,Y) LCO) .

    crl [rcvPathNegotiationYielding2] :
        < OID : Robot | coordinate : (X,Y), 
            remainingPath : LCO, 
            negotiations : NS >
        < OID2 : Map | >
        msg requestPath 
            & path((X2,Y2) LCO2)
            & PS from OID3 to OID
        =>
        < OID2 : Map | >
        if OID < OID3
        then
            < OID : Robot | >
            unicast(OID, priorityProtected & path((X,Y)), OID3)
        else
            yieldAlgorithm(
                < OID : Robot | state : negotiating, 
                    speed : 0, 
                    negotiations : addNegotiation(NS, 
                            [OID3 | (X2,Y2) | noCost]) >,
                < OID2 : Map | >,
                OID3,
                (X2,Y2) LCO2
            )
        fi
        if  PS == priorityYielding
            and (priorityState(< OID : Robot | 
                        negotiations : endNegotiation(NS, OID3) >) 
                    == priorityYielding)
            and pathConflict((X2,Y2) LCO2, (X,Y) LCO) .

    rl [rcvCompletedYieldingMsg] :
        < OID : Robot | state : FUNC, yieldStatus : YIS >
        msg completedYield from OID2 to OID
        =>
        < OID : Robot  | yieldStatus : removeYieldInfo(OID2, YIS) > .

    rl [rcvWrongWorkerTask] :
        < OID : Worker | >
        msg [OID2, TPT] from OID3 to OID
        =>
        < OID : Worker | > .

    rl [rcvWrongTransporterTask] :
        < OID : Transporter | >
        msg [OID2, WT] from OID3 to OID
        =>
        < OID : Transporter | > .
        
    rl [finishNegotiating] :
        < OID : Robot | state : negotiating, negotiations : empty, waitingStatus : WI >
        =>
        if WI == noWaitingInfo
        then
            < OID : Robot | state : idle >
        else
            < OID : Robot | state : waiting >
        fi .

    crl [rcvTaskMsgReject] :
        < OID : Robot | >
        msg [OID3, TT] from OID2 to OID
        =>
        < OID : Robot | >
        if mustRejectTask(< OID : Robot  | >) 
            or (not taskTypeMatch(< OID : Robot | >, TT)) 
            or (planPath(< OID : Robot | >, 
                [OID3, TT], < OID2 : Map | >) == nil) . 

    crl [rcvTaskMsgAccept] :
        < OID : Robot | >
        < OID2 : Map | >
        msg [OID3, TT] from OID3 to OID
        =>
        < OID : Robot | >
        < OID2 : Map | >
        unicast(OID, 
            bid cost(
                calcBid(< OID : Robot | >, 
                    [OID3, TT], 
                    < OID2 : Map | >
                )
            ) 
            on [OID3, TT], OID3
        )
        if not mustRejectTask(< OID : Robot | >)
            and taskTypeMatch(< OID : Robot | >, TT)
            and (planPath(< OID : Robot | >, 
                [OID3, TT], < OID2 : Map | >) =/= nil) .

    rl [detectIgnoreFix] :
        < OID : Robot | state : FUNC, 
            detected : ({OID2 : CID | (X,Y) , IS} , REPS), 
            workState : [OID2, fixAt (X,Y), TIME] >
        =>
        < OID : Robot | state : FUNC, detected : REPS > .

    crl [detectIgnore] :
        < OID : Robot | state : INC, detected : REPS >
        =>
        < OID : Robot | detected : empty >
        if REPS =/= empty .

    rl [detectFunctioningRobot] :
        < OID : Robot | state : FUNC, 
            detected : ({OID2 : Robot | FUNC2 , IS} , REPS) >
        < OID3 : Map | >
        =>
        < OID3 : Map | >
        if needNegotiation(< OID : Robot | >, 
            {OID2 : Robot | FUNC2 , IS}, 
            < OID3 : Map | >)
        then
            startNegotiation(< OID : Robot | detected : REPS >, 
                {OID2 : Robot | FUNC2 , IS}, 
                < OID3 : Map | >)
        else
            < OID : Robot | detected : REPS >
        fi .

    crl [detectFixCapable] :
        < OID : Robot | state : FUNC, 
            coordinate : (X,Y), 
            detected : (REP , REPS), 
            obsCoords : LCO,
            workState : WS
        >
        =>
        < OID : Robot | state : planningPath,
            detected : REPS,
            curTask : [getRepOid(REP), fixAt getRepCoord(REP)],
            obsCoords : getRepCoord(REP) LCO
        >
        if canComplete(< OID : Robot | >, [getRepOid(REP), fixAt getRepCoord(REP)])
            and isFixable(REP)
            and WS =/= [getRepOid(REP), fixAt getRepCoord(REP)]
            and not getRepCoord(REP) in LCO . 

    crl [detectFixIncapableUnobstructed] :
        {< OID : Robot | state : FUNC,
            coordinate : (X,Y),
            remainingPath : LCO, 
            detected : (REP , REPS),
            obsCoords : LCO2
        >
        CONF}
        =>
        {initiateAuction(
            < OID : Robot | detected : REPS,
                obsCoords : getRepCoord(REP) LCO2
            >,
            [getRepOid(REP), fixAt getRepCoord(REP)],
            CONF
        )
        CONF}
        if isFixable(REP)
            and not canComplete(< OID : Robot | >, 
                    [getRepOid(REP), fixAt getRepCoord(REP)]) 
            and (FUNC =/= moving or 
                (FUNC == moving 
                    and 
                    findPathPair(getRepCoord(REP), 
                        (X,Y) LCO) == nil)) .

    crl [detectFixIncapableObstructed] : 
        {< OID : Robot | state : moving,
            coordinate : (X,Y),
            remainingPath : LCO,
            detected : (REP , REPS),
            obsCoords : LCO2 >
        CONF}
        =>
        {initiateAuction(
            < OID : Robot | state : planningPath,
                speed : 0,
                detected : REPS,
                obsCoords : getRepCoord(REP) LCO2
            >,
            [getRepOid(REP), fixAt getRepCoord(REP)],
            CONF
        )
        CONF}
        if isFixable(REP)
            and findPathPair(getRepCoord(REP), (X,Y) LCO) =/= nil
            and not canComplete(< OID : Robot | >, 
                [getRepOid(REP), fixAt getRepCoord(REP)]) .



    crl [startObstacleRemoval] :
        < OID : Robot | coordinate : (X,Y), curTask : [OID2, fixAt (X2,Y2)], workState : noWork >
        < OID2 : Obstacle | coordinate : (X2,Y2) >
        =>
        < OID : Robot | state : fixing, remainingPath : nil, speed : 0, workState : [OID2, (fixAt (X2,Y2)), REMOVAL-TIME] >
        < OID2 : Obstacle | > 
        if canComplete(< OID : Robot | >, [OID2, fixAt (X2,Y2)]) and distance((X,Y), (X2,Y2)) <= WORK-RANGE .

    rl [finishObstacleRemoval] :
        < OID : Robot | coordinate : (X,Y), curTask : [OID2, fixAt (X2,Y2)], workState : [OID2, (fixAt (X2,Y2)), 0] >
        < OID2 : Obstacle | coordinate : (X2,Y2) >
        CONF
        =>
        < OID : Robot | state : idle, curTask : noTask, workState : noWork >
        CONF .

    crl [startRobotRepair] :
        < OID : Robot | coordinate : (X,Y), curTask : [OID2, fixAt (X2,Y2)], workState : noWork >
        < OID2 : Robot | coordinate : (X2,Y2), state : INC > 
        =>
        < OID : Robot | state : fixing, speed : 0, workState : [OID2, (fixAt (X2,Y2)), REPAIR-TIME] >
        < OID2 : Robot | >
        if canComplete(< OID : Robot | >, [OID2, fixAt (X2,Y2)]) and distance((X,Y), (X2,Y2)) <= WORK-RANGE .

    rl [finishRobotRepair] :
        < OID : Robot | coordinate : (X,Y), curTask : [OID2, fixAt (X2,Y2)], workState : [OID2, (fixAt (X2,Y2)), 0] >
        < OID2 : Robot | state : INC, coordinate : (X2,Y2) >
        =>
        < OID : Robot | state : idle, curTask : noTask, workState : noWork > 
        < OID2 : Robot | state : idle > .

    crl [requestHelp] :
        {< OID : Robot | state : INC, 
            coordinate : (X,Y), 
            activeTasks : TTS >
        CONF}
        =>
        {initiateAuction(< OID : Robot | 
                activeTasks : fixAt (X,Y) , TTS >, 
            [OID, fixAt (X,Y)], 
            CONF)
        CONF}
        if not fixAt (X,Y) in TTS .

    crl [startResupply] :
        < OID : Robot | state : FUNC, coordinate : (X,Y), curTask : TID >
        < OID2 : ResupplySite | coordinate : (X,Y) >
        =>
        < OID : Robot | speed : 0, state : resupplying, workState : [OID2, resupplyTask, RESUPPLY-TIME] > 
        < OID2 : ResupplySite | >
        if $needResupply(< OID : Robot | >, TID) and FUNC =/= resupplying .

    rl [finishResupply] :
        < OID : Robot | coordinate : (X,Y), state : resupplying, curTask : [OID2, TT], workState : [OID3, resupplyTask, 0] >
        < OID4 : Map | intersections : < OID3 : ResupplySite | coordinate : (X,Y) > CONF >
        =>
        finishedResupply(< OID : Robot | workState : noWork >, TT)
        < OID4 : Map | > .

    rl [startUnloading] : 
        < OID : Transporter | state : FUNC, coordinate : (X,Y), curCargo : produce, cargoLevel : full, workState : noWork >
        < OID2 : CollectionSite | coordinate : (X,Y) >
        =>
        < OID : Transporter | speed : 0, state : unloading,  workState : [OID2, unloadTask, UNLOAD-TIME] >
        < OID2 : CollectionSite | coordinate : (X,Y) > .

    rl [finishUnloading] :
        < OID : Transporter | state : unloading, curCargo : produce, coordinate : (X,Y), cargoLevel : full, 
            curTask : [OID2, unloadTask], workState : [OID2, unloadTask, 0] >
        < OID3 : CollectionSite | coordinate : (X,Y), collections : N >
        =>
        < OID : Transporter | state : idle, cargoLevel : emptyCargo, curTask : noTask, workState : noWork >
        < OID3 : CollectionSite | coordinate : (X,Y), collections : N + 1 > .

    rl [startGrowingLocTask] :
        < OID : Robot | state : FUNC, coordinate : (X,Y), curTask : [OID2, TT], remainingPath : nil, workState : noWork >
        < OID2 : Field | growingArea : A, coordinate : (X,Y), reserved : false >
        =>
        < OID : Robot | remainingPath : (X,Y) coverArea((X,Y), A), workState : [OID2, TT], speed : 1, state : moving >
        < OID2 : Field | reserved : true > .

    rl [finishWorkerFieldTask] :
        < OID : Worker | state : FUNC, coordinate : (X,Y), remainingPath : nil, workState : [OID2, WT], cargoLevel : full >
        < OID2 : Field | coordinate : (X,Y), reserved : true >
        =>
        < OID : Worker | cargoLevel : emptyCargo, curTask : noTask, workState : noWork >
        taskComplete(< OID2 : Field | >, WT) . 

    rl [finishHarvestTask] :
        < OID : Transporter | state : FUNC, 
            coordinate : (X,Y), 
            curTask : [OID2, harvestTask], 
            remainingPath : nil, 
            workState : [OID2, harvestTask], 
            cargoLevel : emptyCargo >
        < OID2 : Field | coordinate : (X,Y), reserved : true >
        < OID3 : CollectionSite | >
        =>
        < OID : Transporter | state : planningPath,
            cargoLevel : full, 
            curTask : [OID3, unloadTask], 
            workState : noWork >
        taskComplete(< OID2 : Field | >, harvestTask)
        < OID3 : CollectionSite | > .
endom