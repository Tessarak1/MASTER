load time-inf .
load pathfinder .
load message .
load map .
load field .
load obstacle .
load buildings .
load auctioneer .
load fail .
load entity
omod ROBOT is 
    protecting AUCTIONEER .
    protecting FAIL .
    protecting MESSAGE .
    protecting OBSTACLE .
    protecting MAP .
    protecting TIME-INF .
    protecting FIELD .
    protecting PATHFINDER .
    protecting BUILDINGS .
    protecting ENTITY .

    sort CargoLevel .
    sorts WorkerCargo TransporterCargo Cargo .
    sorts Seed Water Fertilizer Produce .
    sort Representation .
    sorts WorkState ActiveWork TimedWork .
    sort Information .
    sort Negotiation .

    subsorts Location Direction State < Information .
    subsorts ActiveWork TimedWork < WorkState .
    subsort Seed Water Fertilizer < WorkerCargo .
    subsort Produce < TransporterCargo .
    subsort TransporterCargo WorkerCargo < Cargo .

    class Robot | detectionRange : Rat, cargoLevel : CargoLevel, curCargo : Cargo,
        detected : Representation, obstructionPoints : List-Location, waitingOn : OidSet,
        curTask : TaskStatus, workState : WorkState, negotiations : Negotiation .
    class Worker .
    class Transporter .
    
    subclass Worker Transporter < Robot < Entity Auctioneer .

    op noNegotiation : -> Negotiation [ctor] .
    op [_| cost_] : Oid RatInf -> Negotiation [ctor] .
    op __ : Negotiation Negotiation -> Negotiation [assoc comm id: noNegotiation] .

    op water : -> Water [ctor] .
    op fertilizer : -> Fertilizer [ctor] .
    op seed : -> Seed [ctor] .

    op needNegotiation : Object Representation Object -> Bool .
    op startNegotiation : Object Representation Object -> Configuration .
    op $timeCheck : Object Oid Time -> Object .
    op $locationChange : Object Location -> Object .
    ops $locationPrevention $speedPrevention : Object Representation -> Object .
    op crashPrevention : Object Representation -> Object .
    op safetyChecks : Object Representation Object -> Configuration .

    op remove : Oid Configuration -> Configuration .
    op _;_ : Information Information -> Information [ctor assoc comm id: noInfo] .
    op noInfo : -> Information [ctor] .
    op TaskNr:_ : Nat -> Information [ctor] .
    op detectedSpeed : Rat -> Information [ctor] .
    op [W:_ F:_ H:_] : Level Level GrowingState -> Information [ctor] .

    ops noWork : -> WorkState [ctor] .
    op [__] : Oid TaskType -> ActiveWork [ctor] .
    op [___] : Oid TaskType Time -> TimedWork [ctor] .
    ops empty full : -> CargoLevel [ctor] .
    op pathConflict : List-Location List-Location RoadSet -> List-Location .

    op nil : -> Representation [ctor] .
    op __ : Representation Representation -> Representation [assoc comm id: nil ctor] .
    op {_:_|_} : Oid Cid Information -> Representation .
    op _notIn_ : String Representation -> Bool .
    op getLocation : Object -> Location .
    ops breaksPath $breaksPath : List-Location Representation -> Bool .
    op canCompleteNow : Object Tid -> Bool .
    op $parseTasksGL : Representation -> TidSet .
    op parseTasksGL : Representation -> TidSet .
    op assignTask : Object Tid -> Object .
    op calculatePathLength : Object Tid Object -> Rat .
    op prepareAuction : Object TidSet -> Configuration .
    op auctionTimer : -> Timer .
    ops rejectTask rejectMsg : Object -> Bool .
    op startWorkGL : Object -> Object .

    ops SAFE-SPEED MAX-SPEED : -> Rat .
    ops SAFE-TIME EMERGENCY-TIME REMOVAL-TIME REPAIR-TIME : -> Time .
    ops WORK-RANGE FINAL-RANGE : -> Rat .
    op ROBOT-SIZE : -> Rat .

    ops needsResupply needsCPoint : Object Tid -> Bool .
    ops resupplyLocCheck cPointLocCheck : Object Tid Location -> List-Location .
    op performChecks : Object Tid Configuration -> List-Location .
    op $planPathLocations : Object Tid Configuration -> List-Location .
    op $planPath : Object List-Location List-Location -> List-Location .

    ***Path that robot must traverse to be able to complete task.
    ***Travels to resupply and/or collection station if needed
    op planPath : Object Tid Configuration -> List-Location .

    ***Adds the locations in the second list that are between locations in the first to the first list.
    op modifyPath : List-Location List-Location -> List-Location .

    op sameDestination : Location Configuration -> Configuration .
    op closest : Location Configuration Configuration -> Configuration .

    op $yieldLocationHelper : Location RoadSet -> Location .
    op yieldLocation : Object RoadSet List-Location -> List-Location .

    ***rename this, it should do the entire yielding check.
    op yieldIntersection : PQueue Object List-Location Location List-Location -> List-Location .
    
    op yieldPath : Object Object List-Location -> List-Location .

    op yieldProtocol : Object Oid List-Location -> Object .

    op __leadsTo_ : Location Direction Location -> Bool .

    op directConflict : List-Location List-Location -> Bool .

    ***Treats the location as an obstacle, and calculates the additional distance required to complete the robot's task.
    op replanCost : Object Object Location -> RatInf .

    vars CONF CONF2 : Configuration .
    vars OID OID2 OID3 OID4 : Oid .
    vars X Y X2 Y2 X3 Y3 X4 Y4 X5 Y5 : Rat .
    var RI : RatInf .
    var N : Nat .
    var A : Area .
    vars LL LL2 LL3 : List-Location .
    vars L L2 : Level .
    var GS : GrowingState .
    var TC : TransporterCargo .
    var RS : RoadSet .
    var MC : MsgContent .
    var CID : Cid .
    var I : Information .
    vars D D2 : Direction .
    vars SP SP2 : Rat .
    var STATE : State .
    var REP : Representation .
    vars OS OS2 : OidSet .
    var T : Timer .
    vars TIME TIME2 : Time .
    vars TID TID2 : Tid .
    var TIDS : TidSet .
    vars AS AS2 : AttributeSet .
    var CL : CargoLevel .
    var FUNC : FunctioningState .
    var INC : IncapacitatedState .
    var PQ : PQueue .
    var O : Object . 
    var NS : Negotiation .

    vars TT TT2 : TaskType .
    var TS : TaskStatus .
    var TPT : TransporterTask .
    var WT : WorkerTask .
    var AW : ActiveWork .
    vars WS WS2 : WorkState .
    var TW : TimedWork .
    var AU : Auction .
    var B : Bid .

    eq FINAL-RANGE = 1 .
    eq remove(OID, < OID : Robot | > CONF) = CONF .
    eq remove(OID, CONF) = CONF [owise] .

    eq replanCost(< OID : Robot | curTask : TID, obstructionPoints : LL >, < OID2 : Map | >, (X,Y)) =
        if planPath(< OID : Robot | obstructionPoints : LL (X,Y) >, TID, < OID2 : Map | >) == nil
        then
            ratInf
        else
            ***this may not work if a robot has parsed detection of the other, ensure that it performs without and with added to obstructionpoints.
            listLength(planPath(< OID : Robot | obstructionPoints : LL (X,Y) >, TID, < OID2 : Map | >)) -
            listLength(planPath(< OID : Robot | obstructionPoints : remove(LL, (X,Y)) >, TID, < OID2 : Map | >))
        fi .

    eq WORK-RANGE = 1 .
    eq REMOVAL-TIME = 5 .
    eq REPAIR-TIME = 5 .
    eq SAFE-SPEED = 1 .
    eq MAX-SPEED = 5 .
    eq SAFE-TIME = 5 .
    eq EMERGENCY-TIME = 3 .
    eq ROBOT-SIZE = 1 .

    ***There is a path conflict if the paths share an intersection in the same direction, or if they share a path going in opposite directions
    ceq directConflict((X,Y) (X2,Y2) LL, (X3,Y3) (X2,Y2) LL2) = true if setDirection((X,Y),(X2,Y2)) =/= setDirection((X3,Y3), (X2,Y2)) . 
    ceq directConflict((X,Y) (X2,Y2) (X3,Y3) LL, (X4,Y4) (X5,Y5) LL2) = true if overlap((X2,Y2) (X3,Y3), (X4,Y4) (X5,Y5)) and opposite(setDirection((X2,Y2), (X3,Y3)), setDirection((X4,Y4), (X5,Y5))) .
    ceq directConflict((X,Y) (X2,Y2) LL, (X3,Y3) (X4,Y4) LL2) = true if
        overlap((X,Y) (X2,Y2), (X3,Y3) (X4,Y4)) and opposite(setDirection((X,Y), (X2,Y2)), setDirection((X3,Y3), (X4,Y4))) .
    eq directConflict(LL, LL2) = false [owise] .

    ceq safetyChecks(< OID : Robot | state : STATE >, {OID2 : Robot | I}, < OID3 : Map | >) = < OID : Robot | > if STATE == idle or STATE == waiting .
    eq safetyChecks(< OID : Robot | >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >) =
        ***this correct, what if we detect someone that are not in the way?
        ***unchanged since it is not in the way.
        if needNegotiation(< OID : Robot | >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >)
        then
            startNegotiation(< OID : Robot | >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >)
        else
            crashPrevention(< OID : Robot | >, {OID2 : Robot | FUNC ; I})
        fi .
    ***Crash prevention consists of changing speed and/or the remaining path if relevant.
    eq crashPrevention(< OID : Robot | location : (X,Y), remainingPath : LL >, {OID2 : CID | (X2,Y2) ; I}) = 
        if between((X2, Y2), (X,Y) LL) =/= nil
        then
            $speedPrevention($locationPrevention(< OID : Robot | >, {OID2 : CID | (X2,Y2) ; I}), {OID2 : CID | (X2,Y2) ; I})
        else
            < OID : Robot | >
        fi .

    ***Location change is only performed when detecting an immobile object.
    ***If the task is to fix the robot, then we are not waiting on it, but otherwise we are.
    ***ceq $locationPrevention(< OID : Robot | waitingOn : OS >, {OID2 : Robot | (X2,Y2) ; FUNC ; I}) = if STATE =/= moving .
    eq $locationPrevention(< OID : Robot | >, {OID2 : Robot | moving ; I}) = < OID : Robot | > .
    eq $locationPrevention(< OID : Robot | location : (X,Y), remainingPath : LL >, {OID2 : Robot | (X2,Y2) ; INC ; I}) = $locationChange(< OID : Robot | remainingPath : (X,Y) LL >, (X2,Y2)) .
    eq $locationPrevention(< OID : Robot | location : (X,Y), remainingPath : LL >, {OID2 : Obstacle | (X2,Y2)}) = $locationChange(< OID : Robot | remainingPath : (X,Y) LL >, (X2,Y2)) .
 
    eq $locationChange(< OID : Robot | remainingPath : LL (X,Y) (X,Y2) >, (X,Y2)) =
        if Y > Y2
        then
            < OID : Robot | remainingPath : LL (X,Y) (X,Y2 + ROBOT-SIZE) >
        else
            < OID : Robot | remainingPath : LL (X,Y) (X,Y2 - ROBOT-SIZE) >
        fi .
    eq $locationChange(< OID : Robot | remainingPath : LL (X,Y) (X2,Y) >, (X2,Y)) =
        if X > X2
        then
            < OID : Robot | remainingPath : LL (X,Y) (X2 + ROBOT-SIZE,Y) >
        else
            < OID : Robot | remainingPath : LL (X,Y) (X2 - ROBOT-SIZE,Y) >
        fi .

    ***Only location change is needed here to prevent the Robot's path from overlapping with the obstacle.
    ***Speed change is dependent on the time it would take until the robot would crash with the detected object.
    eq $speedPrevention(< OID : Robot | >, {OID2 : Obstacle | I}) = < OID : Robot | > .
    eq $speedPrevention(< OID : Robot | location : (X,Y), direction : D, speed : SP, waitingOn : OS >, {OID2 : Robot | (X2,Y2) ; D ; detectedSpeed(SP2) ; moving ; I}) =
        if SP2 >= SP
        then
            < OID : Robot | >
        else
            $timeCheck(< OID : Robot | >, OID2, distance((X,Y), (X2,Y2)) / (SP - SP2))
        fi .
    ceq $speedPrevention(< OID : Robot | location : (X,Y), direction : D, speed : SP >, {OID2 : Robot | (X2, Y2) ; D2 ; detectedSpeed(SP2) ; moving ; I}) =
        $timeCheck(< OID : Robot | >, OID2, distance((X,Y), (X2,Y2)) / (SP + SP2))
        if opposite(D, D2) .
    eq $speedPrevention(< OID : Robot | >, {OID2 : Robot | I}) = < OID : Robot | > [owise] .

    ***Modifies the robot's speed based on the calculated time until crash.
    eq $timeCheck(< OID : Robot | waitingOn : OS >, OID2, TIME) =
        if TIME < EMERGENCY-TIME
        then
            < OID : Robot | state : idle, speed : 0 >
        else
            if TIME < SAFE-TIME 
            then
                < OID : Robot | speed : SAFE-SPEED >
            else
                < OID : Robot | >
            fi
        fi .

    ceq (X,Y) north leadsTo (X,Y2) = true if Y2 > Y .
    ceq (X,Y) south leadsTo (X,Y2) = true if Y2 < Y .
    ceq (X,Y) east leadsTo (X2,Y) = true if X2 > X .
    ceq (X,Y) west leadsTo (X2,Y) = true if X2 < X .
    eq (X,Y) D leadsTo (X2,Y2) = false [owise] .

    ***Need to find a better way to know if two robots are headed towards one another, or they share the same path
    ***as findRoad can return the entire pathset of.
    ***check first two instead of just location?
    ***I need a better way to orient robots. regardless of if they are on intersections or not.
    ***it has location and remainingpath and direction, this is what I can use.
    ***Have been using findroad for orientation, this is the only problem with it.
    ***

    ***Moving in same direction = false
    ***Need to start negotation if two robots move towards each other directly, without any intersection in the middle.
    ceq needNegotiation(< OID : Robot | location : (X,Y), direction : D, state : moving >,
        {OID2 : Robot | (X2,Y2) ; D2 ; moving ; I}, < OID3 : Map | roads : {(X3,Y3) (X4,Y4)} RS >) =
            true if opposite(D,D2) and (findRoad((X,Y), {(X3,Y3) (X4,Y4)}) == findRoad((X2,Y2), {(X3,Y3) (X4,Y4)})) .
    ***If a robot is moving towards a stationary robot that is in the way.
    ceq needNegotiation(< OID : Robot | location : (X,Y), remainingPath : LL, state : moving >,
        {OID2 : Robot | (X2,Y2) ; STATE ; I}, < OID3 : Map | roads : RS >) =
            true if (STATE =/= moving) and (between((X,Y) LL, (X2,Y2)) =/= nil) .
    ***two robots move towards the same intersection from different paths.
    ceq needNegotiation(< OID : Robot | location : (X,Y), state : moving, direction : D >,
        {OID2 : Robot | (X2,Y2) ; D2 ; I}, < OID3 : Map | roads : {(X3,Y3) (X4,Y4)} {(X4, Y4) (X5,Y5)} RS >) =
            true if (X,Y) inRange({(X3,Y3) (X4,Y4)}) and (X2,Y2) inRange({(X4, Y4) (X5,Y5)}) and ((X,Y) D leadsTo (X4,Y4)) and ((X2,Y2) D2 leadsTo (X4,Y4)) .    
    eq needNegotiation(< OID : Robot | >, {OID2 : Robot | I}, < OID3 : Map | >) = false [owise] .

    eq startNegotiation(< OID : Robot | location : (X,Y), remainingPath : LL, waitingOn : OS, negotiations : >, {OID2 : Robot | (X2,Y2) ; I}, < OID3 : Map | >) =
        < OID : Robot | state : waiting, speed : 0, waitingOn : OID2 OS >
        dly(msg requestPath ยง path((X,Y) LL) from OID to OID2, MSG-DELAY) .

    eq closest((X,Y), CONF, none) = CONF .
    eq closest((X,Y), < OID : Robot | location : (X2,Y2), direction : D > CONF, < OID2 : Robot | location : (X3,Y3), direction : D > CONF2) =
        if distance((X,Y), (X2,Y2)) < distance((X,Y), (X3,Y3))
        then
            closest((X,Y), < OID : Robot | > CONF, CONF2)
        else
            closest((X,Y), < OID2 : Robot | > CONF, CONF2)
        fi .
    eq closest((X,Y), CONF, < OID : Robot | > CONF2) = closest((X,Y), < OID : Robot | > CONF, CONF2) .
    
    eq sameDestination((X,Y), < OID : Robot | remainingPath : (X,Y) LL > CONF) = < OID : Robot | > sameDestination((X,Y), CONF) .
    eq sameDestination((X,Y), CONF) = none [owise] .

    eq getLocation(< OID : Robot | location : (X,Y) >) = (X,Y) .
    eq decreaseTimers(< OID : Robot | state : removing, workState : [OID2 (removeAt (X,Y)) TIME] >, TIME2) = < OID : Robot | workState : [OID2 (removeAt (X,Y)) (TIME monus TIME2)] > .
    eq decreaseTimers(< OID : Robot | state : repairing, workState : [OID2 (repairAt (X,Y)) TIME] >, TIME2) = < OID : Robot | workState : [OID2 (repairAt (X,Y)) (TIME monus TIME2)] > .
    eq decreaseTimers(< OID : Robot | >, TIME) = < OID : Robot | > [owise] .
    eq rejectTask(< OID : Robot | state : STATE, curTask : TS >) = rejectMsg(< OID : Robot | >) or (TS =/= noTask) .
    eq rejectMsg(< OID : Robot | state : INC >) = true .
    eq rejectMsg(< OID : Robot | >) = false [owise] .
    eq needsCPoint(< OID : Worker | >, TID) = false .
    eq needsCPoint(< OID : Transporter | cargoLevel : CL >, TID) = CL == full .
    eq needsResupply(< OID : Worker | curCargo : fertilizer >, [OID2, watering, N]) = true .
    eq needsResupply(< OID : Worker | curCargo : water >, [OID2, fertilize, N]) = true .
    eq needsResupply(< OID : Worker | cargoLevel : empty >, TID) = true .
    eq needsResupply(< OID : Robot | >, TID) = false [owise] .
    eq cPointLocCheck(< OID : Robot | >, TID, (X,Y)) = if needsCPoint(< OID : Robot | >, TID) then (X,Y) else nil fi .
    eq resupplyLocCheck(< OID : Robot | >, TID, (X,Y)) = if needsResupply(< OID : Robot | >, TID) then (X,Y) else nil fi .
    eq performChecks(< OID : Robot | >, TID, < OID2 : ResupplyStation | location : (X,Y) > < OID3 : CollectionStation | location : (X2,Y2) > CONF) =
        resupplyLocCheck(< OID : Robot | >, TID, (X,Y)) cPointLocCheck(< OID : Robot | >, TID, (X2,Y2)) .

    ceq canCompleteNow(< OID : Worker | state : FUNC, curTask : TS >, [OID2, removeAt (X,Y), N]) = true if (TS == noTask) or (TS == [OID2, removeAt (X,Y), N]) .
    ceq canCompleteNow(< OID : Worker | state : FUNC, curTask : TS >, [OID2, repairAt (X,Y), N]) = true if (TS == noTask) or (TS == [OID2, repairAt (X,Y), N]) .
    eq canCompleteNow(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : water >, [OID2, watering, N]) = true .
    eq canCompleteNow(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : fertilizer >, [OID2, fertilize, N]) = true .
    eq canCompleteNow(< OID : Transporter | cargoLevel : empty >, [OID2, harvest, N]) = true .
    eq canCompleteNow(< OID : Robot | state : INC >, TID) = false .
    ceq canCompleteNow(< OID : Robot | curTask : TID >, TID2) = false if TID =/= noTask .
    eq canCompleteNow(< OID : Robot | >, TID) = false [owise] .

    eq calculatePathLength(< OID : Robot | >, TID, < OID2 : Map | >) = listLength(planPath(< OID : Robot | >, TID, < OID2 : Map | >)) .

    ***Returns the locations the robot must visit on its path to complete the task.
    eq $planPathLocations(< OID : Robot | location : (X,Y) >, [OID2, TT, N], < OID2 : Locatable | location : (X2,Y2) > CONF) =
        (X,Y) performChecks(< OID : Robot | >, [OID2, TT, N], < OID2 : Locatable | location : (X2,Y2) > CONF) (X2,Y2) .

    eq $planPath(< OID : Map | >, LL, LL2) = dijkstraChain(getIntersections(modifyMap(< OID : Map | >, LL, LL2)), LL) .

    ***planPathLocations is used to 
    eq planPath(< OID : Robot | location : (X,Y), obstructionPoints : LL >, [OID2, TT, N], < OID3 : Map | allIntersections : CONF > CONF2) =
        $planPath(< OID3 : Map | >,
            $planPathLocations(< OID : Robot | >, [OID2, TT, N], CONF CONF2), LL) .

    ceq modifyPath(LL (X,Y) (X2,Y2) LL2, (X3,Y3) LL3) = modifyPath(LL (X,Y) (X3,Y3) (X2,Y2), LL3)
        if ((X3,Y3) =/= (X,Y) and (X3,Y3) =/= (X2,Y2) and between((X3,Y3), (X,Y) (X2,Y2)) =/= nil) . 
    eq modifyPath(LL, LL2) = LL [owise] .

    eq OID notIn {OID : CID | (X,Y) ; I} REP = false .
    eq OID notIn REP = true [owise] .
    ceq $breaksPath((X,Y) (X,Y2), {OID2 : CID | (X,Y3) ; north ; I}) = true if Y > Y2 .
    ceq $breaksPath((X,Y) (X2,Y), {OID2 : CID | (X3,Y) ; east ; I}) = true if X > X2 .
    ceq $breaksPath((X,Y) (X,Y2), {OID2 : CID | (X,Y3) ; south ; I}) = true if Y < Y2 .
    ceq $breaksPath((X,Y) (X2,Y), {OID2 : CID | (X3,Y) ; west ; I}) = true if X < X2 .
    eq $breaksPath(LL, REP) = false [owise] .
    
    ceq breaksPath(LL, {OID2 : CID | (X,Y) ; I}) = false if between((X,Y), LL) == nil .
    eq breaksPath(LL, {OID2 : Obstacle | (X,Y) ; I}) =
        if between((X,Y), LL) == nil then
            false
        else
            true
        fi .
    eq breaksPath(LL, {OID2 : CID | (X,Y) ; D ; I}) = $breaksPath(between((X,Y), LL), {OID2 : CID | (X,Y) ; D ; I}) .
    
    *** X,Y is the location of chosen intersection, the pathset are paths not used and any one of them can therefore be a yield location.
    eq $yieldLocationHelper((X,Y), {(X,Y) (X,Y2)} RS) =
        if Y < Y2
        then
            (X, Y + ROBOT-SIZE)
        else
            (X, Y - ROBOT-SIZE)
        fi .
    eq $yieldLocationHelper((X,Y), {(X,Y) (X2,Y)} RS) =
        if X < X2
        then
            (X + ROBOT-SIZE, Y)
        else
            (X - ROBOT-SIZE, Y)
        fi .

    ***Checks if an intersection has a viable yield location, a location that the robot can stop on and not be in the way of LL (X,Y) LL2.
    ***Uses findRoad to get the connecting paths of the intersection and checks if it has any that are not used by LL LL2
    eq yieldLocation(< OID : Intersection | location : (X,Y) >, RS, LL (X,Y) LL2) =
        ***This check is not good enough since a robot may have a path that is different from the other robots understanding of the map.
        if findRoad((X,Y), RS) \ findRoad(last(LL) first(LL2), RS) =/= es then
            $yieldLocationHelper((X,Y), findRoad((X,Y), RS) \ findRoad(last(LL) first(LL2), RS))
        else
            nil
        fi .

    ***Send in modifymap and modify path and UpdateDistances(PQ) for this.
    eq yieldIntersection(noQueue, < OID : Map | >, LL, (X,Y), LL2) = LL2 .
    eq yieldIntersection([< OID : Intersection | location : (X,Y) >, 0, "Start"] PQ, < OID2 : Map | allIntersections : CONF, roads : RS >, LL, (X,Y), nil) = 
        if yieldLocation(< OID : Intersection | >, RS, LL) =/= nil
        then
            yieldLocation(< OID : Intersection | >, RS, LL)
        else
            yieldIntersection(PQ, < OID2 : Map | >, LL, (X,Y), nil)
        fi .
    ceq yieldIntersection([< OID : Intersection | location : (X,Y) >, RI, OID2] PQ, < OID3 : Map | allIntersections : CONF, roads : RS >, LL, (X2,Y2), nil) =
        if RI == ratInf
        then
            none
        else
            if yieldLocation(< OID : Intersection | >, RS, LL) =/= nil
            then
                if not directConflict(dijkstraSearch(CONF, (X2,Y2), (X,Y)), LL)
                then
                    dijkstraSearch(CONF, (X2,Y2), (X,Y)) yieldLocation(< OID : Intersection | >, RS, LL)
                else
                    yieldIntersection(PQ, < OID3 : Map | >, LL, (X2,Y2), dijkstraSearch(CONF, (X2,Y2), (X,Y)))
                fi
            else
                yieldIntersection(PQ, < OID3 : Map | >, LL, (X2,Y2), LL)
            fi
        fi
        if OID2 =/= "Start" .

    ceq yieldIntersection([< OID : Intersection | location : (X,Y) >, RI, OID2] PQ, < OID3 : Map | allIntersections : CONF, roads : RS >, LL, (X2,Y2), LL2) =
        if RI == ratInf
        then
            none
        else
            if yieldLocation(< OID : Intersection | >, RS, LL) =/= nil
            then
                if not directConflict(dijkstraSearch(CONF, (X2,Y2), (X,Y)), LL)
                then
                    dijkstraSearch(CONF, (X2,Y2), (X,Y)) yieldLocation(< OID : Intersection | >, RS, LL)
                else
                    yieldIntersection(PQ, < OID3 : Map | >, LL, (X2,Y2), LL2)
                fi
            else
                yieldIntersection(PQ, < OID3 : Map | >, LL, (X2,Y2), LL2)
            fi
        fi
        if OID2 =/= "Start" .


    ***Returns the path the robot must take to avoid conflict with another path, LL2.
    ***returns nil if there is none.
    eq yieldPath(< OID : Robot | location : (X,Y), obstructionPoints : LL >, < OID2 : Map | >, LL2) =
        yieldIntersection(
            updateDistances(PQConvert(getIntersections(modifyMap(< OID2 : Map | >, (X,Y), LL)), (X,Y))),
            modifyMap(< OID2 : Map | >, (X,Y), LL),
            modifyPath(LL2, (X,Y)),
            (X,Y),
            nil
        ) .

    ceq yieldProtocol(< OID : Robot | remainingPath : LL >, OID2, LL2) =
        < OID : Robot | remainingPath : LL2 >
        dly(msg yielding from OID to OID2, MSG-DELAY)
        if LL2 =/= nil .

    rl [rcvCostMsg] :
        < OID : Robot | negotiations : [OID2 | cost RI] >
        msg cost(RI2) from OID2 to OID
        =>
        
        

    rl [fail] :
        < OID : Robot | location : (X,Y), curTask : TS >
        < "FAIL" : Fail | >
        =>
        if TS == noTask
        then
            < OID : Robot | speed : 0, state : failed >
        else
            startAuction(< OID : Robot | speed : 0, state : failed >, TS [OID, repairAt (X,Y), 1])
        fi .

    ***when planning path, if it is not possible, then auction away tasks.
    rl [planPath] :
        < OID : Robot | state : planningPath, detected : nil, curTask : TID >
        < OID3 : Map | >
        =>
        if planPath(< OID : Robot | >, TID, < OID3 : Map | >) == nil
        then
            startAuction(< OID : Robot | state : idle, remainingPath : nil, speed : 0 > , TID)
        else
            < OID : Robot | state : moving, remainingPath : planPath(< OID : Robot | >, TID, < OID3 : Map | >) >
            < OID3 : Map | >
        fi .

    ***If the robot is in the way of another when it is idle it yields.
    rl [rcvPathNegotiationIdle] :
        < OID : Robot | location : (X,Y), remainingPath : nil, state : idle >
        < OID2 : Map | >
        msg requestPath ยง path(LL) from OID3 to OID
        =>
        if between((X,Y), LL) =/= nil
        then
            yieldProtocol(
                < OID : Robot | >,
                OID3,
                yieldPath(< OID : Robot | >, < OID2 : Map | >, LL)
            )
            < OID2 :  Map | >
        else
            < OID : Robot | >
            < OID2 : Map | >
            msg noConflict from OID to OID3 
        fi .

    --- rl [rcvPathNegotiationSharedIntersection] :
    ---     < OID : Robot | location : (X,Y), remainingPath : (X2,Y2) LL, curTask : TID, state : FUNC >
    ---     < OID2 : Map | >
    ---     msg requestPath ยง path((X3, Y3) (X2,Y2) LL2) from OID3 to OID 
    ---     =>
    ---     intersectionCoordination.
    ***Dont want direct conflict to override intersection coordination.

    ***If the robot has a task to complete it negotiates with the other to find most cost effective reroute.
    crl [rcvPathNegotiationDirectConflict] :
        < OID : Robot | location : (X,Y), remainingPath : (X2,Y2) LL, curTask : TID, state : FUNC, obstructionPoints : LL2, negotiations : NS >
        < OID2 : Map | >
        msg requestPath ยง path((X3, Y3) (X4,Y4) LL3) from OID3 to OID 
        =>
        ***we need to keep track of negotiations? or can we just make a decision when we retrieve cost?
        ***send cost of replanning, if possible.
        < OID : Robot | negotiations : [OID3 | cost replanCost(< OID : Robot | >, < OID2 : Map | >, (X3, Y3))] NS > 
        < OID2 : Map | >
        dly(msg cost(replanCost(< OID : Robot | >, < OID2 : Map | >, (X3, Y3))) from OID to OID3, MSG-DELAY)
        ***The rule only applies if the robots are headed directly towards one another on the same road.
        ***Modifypath is used so that the rule is not applied if there is an obstacle between them.
        if directConflict((X,Y) (X2,Y2) LL, modifyPath((X3,Y3) (X4,Y4) LL3, LL2)) and ((X2,Y2) =/= (X4, Y4)) .

    ***rcv yieldingON msg.
    ***remove from waitingOn, then if waitingOn is empty, begin moving again, ofc only if functional.
    ***remove from waitingOn, waitingOn can be empty? if it fails we clear waitingOn?
    ***if we are inc
    ***what if receive a yield message if not waiting?
    rl [rcvYieldingMsgValid] :
        < OID : Robot | waitingOn : OS >
        msg yielding from OID2 to OID
        =>
        < OID : Robot | waitingOn : OS \ OID2 > .

    rl [stopWaiting] :
        < OID : Robot | state : waiting, waitingOn : none >
        =>
        < OID : Robot | state : idle > .

    rl [rcvObstacleRemovedMsg] : 
        < OID : Robot | obstructionPoints : LL >
        msg removed (X,Y) from OID2 to OID
        =>
        < OID : Robot | obstructionPoints : remove(LL, (X,Y)) > .
    crl [rcvTaskMsgBusy] :
        < OID : Robot | >
        msg TID from OID2 to OID
        =>
        < OID : Robot | >
        msg busy TID from OID to OID2 
        if rejectTask(< OID : Robot  | >) .
    crl [rcvTaskMsgFree] :
        < OID : Robot | location : (X,Y), obstructionPoints : LL >
        < OID2 : Map | allIntersections : CONF >
        msg [OID3, TT, N] from OID3 to OID
        =>
        < OID : Robot | >
        < OID2 : Map | >
        dly(msg bid calculatePathLength(< OID : Robot | >, [OID3, TT, N], < OID2 : Map | >) on [OID3, TT, N] from OID to OID3, MSG-DELAY)
        if not rejectTask(< OID : Robot | >) .

    rl [winAuction] :
        < OID : Robot | >
        msg won TID from OID2 to OID
        =>
        if rejectMsg(< OID : Robot | >)
        then
            < OID : Robot | >
            dly(msg reject TID from OID to OID2, MSG-DELAY)
        else
            < OID : Robot | state : planningPath, curTask : TID >
            dly(msg accept TID from OID to OID2, MSG-DELAY)
        fi .
    crl [arriveAtFixLoc] :
        < OID : Robot | location : (X,Y), remainingPath : (X,Y), state : STATE >
        =>
        < OID : Robot | remainingPath : nil >
        if (STATE == removing) or (STATE == repairing) .

    rl [detectFunctioningRobot] :
        < OID : Robot | detected : {OID2 : Robot | FUNC ; I} REP >
        < OID3 : Map | >
        =>
        safetyChecks(< OID : Robot | detected : REP >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >)
        < OID3 : Map | > .

    rl [detectFailedRobot] :
        < OID : Robot | location : (X,Y), remainingPath : LL, detected : {OID2 : Robot | INC ; (X2,Y2) ; I} REP, obstructionPoints : LL2, workers : OS >
        < OID2 : Robot | location : (X2,Y2) >
        < OID3 : Map | >
        =>
        if canCompleteNow(< OID : Robot | >, [OID2, repairAt (X2,Y2), 1])
        then
            crashPrevention(< OID : Robot | state : moving,
                remainingPath : planPath(< OID : Robot | >, [OID2, repairAt (X2,Y2), 1], < OID3 : Map | > < OID2 : Robot | >),
                detected : REP, curTask : [OID2, repairAt (X2,Y2), 1], obstructionPoints : (X2,Y2) LL2 >, {OID2 : Robot | INC ; (X2,Y2) ; I})
            < OID2 : Robot | >
            < OID3 : Map | >
        else
            if between((X2,Y2), (X,Y) LL) =/= nil
            then
                startAuction(< OID : Robot | state : planningPath, detected : REP, obstructionPoints : (X2,Y2) LL2 >, [OID2, repairAt (X2,Y2), 1])
                < OID2 : Robot | >
                < OID3 : Map | >
            else
                ***If cant replan then abandon task and fix the broken one.
                startAuction(< OID : Robot | detected : REP, obstructionPoints : (X2, Y2) LL2 >, [OID2, repairAt (X2,Y2), 1])
                < OID2 : Robot | >
                < OID3 : Map | >
            fi
        fi .
    
    rl [detectObstacle] : 
        < OID : Robot | location : (X,Y), remainingPath : LL, detected : {OID2 : Obstacle | (X2,Y2)} REP, obstructionPoints : LL2, workers : OS, transporters : OS2 > 
        < OID2 : Obstacle | location : (X2,Y2) >
        < OID3 : Map | > 
        =>
        if canCompleteNow(< OID : Robot | >, [OID2, removeAt (X2,Y2), 1])
        then
            crashPrevention(< OID : Robot | state : moving,
                remainingPath : planPath(< OID : Robot | >, [OID2, removeAt (X2,Y2), 1], < OID3 : Map | > < OID2 : Obstacle | >),
                detected : REP, curTask : [OID2, removeAt (X2,Y2), 1], obstructionPoints : (X2,Y2) LL2 >, {OID2 : Obstacle | (X2,Y2)})
            broadcast(OID, obstacleAt (X2,Y2), OS OS2)
            < OID2 : Obstacle | >
            < OID3 : Map | >
        else
            if between((X2,Y2), (X,Y) LL) =/= nil
            then
                startAuction(< OID : Robot | state : planningPath, detected : REP, obstructionPoints : (X2,Y2) LL2 >, [OID2, removeAt (X2,Y2), 1])
                < OID2 : Obstacle | >
                < OID3 : Map | >
            else
                startAuction(< OID : Robot | detected : REP, obstructionPoints : (X2, Y2) LL2 >, [OID2, removeAt (X2,Y2), 1])
                < OID2 : Obstacle | >
                < OID3 : Map | >
            fi
        fi .
    crl [startObstacleRemoval] :
        < OID : Robot | location : (X,Y), curTask : [OID2, removeAt (X2,Y2), N], workState : noWork >
        < OID2 : Obstacle | location : (X2,Y2) >
        =>
        < OID : Robot | state : removing, remainingPath : nil, speed : 0, workState : [OID2 (removeAt (X2,Y2)) REMOVAL-TIME] >
        < OID2 : Obstacle | > 
        if canCompleteNow(< OID : Robot | >, [OID2, removeAt (X2,Y2), N]) and distance((X,Y), (X2,Y2)) <= WORK-RANGE .
    crl [startRobotRepair] :
        < OID : Robot | location : (X,Y), curTask : [OID2, repairAt (X2,Y2), N], workState : noWork >
        < OID2 : Robot | location : (X2,Y2), state : failed > 
        =>
        < OID : Robot | state : repairing, workState : [OID2 (repairAt (X2,Y2)) REPAIR-TIME] >
        < OID2 : Robot | >
        if canCompleteNow(< OID : Robot | >, [OID2, repairAt (X2,Y2), N]) and distance((X,Y), (X2,Y2)) <= WORK-RANGE .
    rl [finishObstacleRemoval] :
        < OID : Robot | location : (X,Y), curTask : [OID2, removeAt (X2,Y2), N], workState : [OID2 (removeAt (X2,Y2)) 0],
            workers : OS, transporters : OS2 >
        < OID2 : Obstacle | location : (X2,Y2) >
        =>
        < OID : Robot | speed : 0, state : idle, curTask : noTask, workState : noWork >
        broadcast(OID, removed (X2,Y2), OS OS2) .
    rl [finishRobotRepair] :
        < OID : Robot | location : (X,Y), curTask : [OID2, repairAt (X2,Y2), N], workState : [OID2 (repairAt (X2,Y2)) 0] >
        < OID2 : Robot | state : failed, location : (X2,Y2) >
        =>
        < OID : Robot | speed : 0, state : idle, curTask : noTask, workState : noWork >
        < OID2 : Robot | state : idle > .
    crl [startResupply] :
        < OID : Robot | state : FUNC, location : (X,Y), curTask : TID >
        < OID2 : Map | allIntersections : < OID3 : ResupplyStation | location : (X,Y), AS > CONF >
        =>
        < OID : Robot | state : resupplying > 
        < OID2 : Map | > 
        if needsResupply(< OID : Robot | >, TID) .
    rl [finishResupply] :
        < OID : Robot | location : (X,Y), state : resupplying, curTask : [OID2, TT, N] >
        < OID3 : Map | allIntersections : < OID4 : ResupplyStation | location : (X,Y), AS > CONF > 
        =>
        if (TT == watering)
        then
            < OID : Robot | state : moving, curCargo : water, cargoLevel : full >
            < OID3 : Map | >
        else
            if (TT == fertilize)
            then
                < OID : Robot | state : moving, curCargo : fertilizer, cargoLevel : full >
                < OID3 : Map | >
            else
                < OID : Robot | state : moving >
                < OID3 : Map | >
            fi
        fi .
    rl [startGrowingLocTask] :
        < OID : Robot | location : (X,Y), curTask : [OID2, TT, N], remainingPath : nil, workState : noWork >
        < OID2 : Field | growingArea : A, location : (X,Y) >
        =>
        if canCompleteNow(< OID : Robot | >, [OID2, TT,N])
        then
            < OID : Robot | remainingPath : coverArea((X,Y), A), workState : [OID2 TT], speed : 1, state : moving >
            < OID2 : Field | >
        else
            < OID : Robot | state : planningPath >
            < OID2 : Field | >
        fi .
    rl [finishGrowingLocTask] :
        < OID : Robot | location : (X,Y), curTask : [OID2, TT, N], remainingPath : nil, workState : [OID2 TT] >
        < OID2 : Field | location : (X,Y) >
        =>
        < OID : Robot | cargoLevel : empty, curTask : noTask, workState : noWork >
        taskComplete(< OID2 : Field | >, [OID2, TT, N]) .  
endom

