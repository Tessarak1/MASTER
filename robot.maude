load time-inf .
load pathfinder .
load message .
load map .
load field .
load obstacle .
load buildings .
load auctioneer .
load entity .
load systemVars .

omod ROBOT is 
    protecting AUCTIONEER .
    protecting MESSAGE .
    protecting OBSTACLE .
    protecting MAP .
    protecting TIME-INF .
    protecting FIELD .
    protecting PATHFINDER .
    protecting BUILDINGS .
    protecting ENTITY .
    protecting SYSTEM-VARS .

    sort CargoLevel .
    sorts WorkerCargo TransporterCargo Cargo .
    sorts Seed Water Fertilizer Produce .
    sorts Representation RepresentationSet .
    sorts WorkState TimedWork .
    sort Information .
    sorts YieldInformation YieldInformationSet .
    sort BaseInformation BaseInformationSet WaitingInformation .
    sort PriorityState .

    subsorts Location Direction State < Information .
    subsorts Tid TimedWork < WorkState .
    subsort Seed Water Fertilizer < WorkerCargo .
    subsort Produce < TransporterCargo .
    subsort TransporterCargo WorkerCargo < Cargo .
    subsort Representation < RepresentationSet .
    subsort YieldInformation < YieldInformationSet .
    subsort BaseInformation < BaseInformationSet .
    subsort PriorityState < MsgContent .

    class Robot | detectionRange : Rat, cargoLevel : CargoLevel, curCargo : Cargo,
        detected : RepresentationSet, obstructionPoints : List-Location,
        curTask : TaskStatus, workState : WorkState, negotiations : NegotiationSet, yieldStatus : YieldInformationSet, waitingStatus : WaitingInformation .
    class Worker .
    class Transporter .
    
    subclass Worker Transporter < Robot < Entity Auctioneer .

    ops priorityIdle priorityTask priorityYielding priorityNegotiating priorityWaiting priorityWorking : -> PriorityState [ctor] .
    op priorityState : Object -> PriorityState .

    op [_-_] : Oid Location -> BaseInformation [ctor] .
    op noBaseInformation : -> BaseInformation [ctor] .
    op _,_ : BaseInformationSet BaseInformationSet -> BaseInformationSet [ctor assoc comm id: noBaseInformation] .
    op noWaitingInformation : -> WaitingInformation [ctor] .
    op [_|_|_] : BaseInformationSet Timer Timer -> WaitingInformation [ctor] .
    op getWaitingTimer : WaitingInformation -> TimerSet .
    op decreaseWaitingTimers : WaitingInformation Time -> WaitingInformation .
    op rescanWaitingOn : BaseInformationSet Configuration -> BaseInformationSet .
    op inDetectionRange : Object Configuration -> Configuration .
    op addWaiting : WaitingInformation Oid Location -> WaitingInformation .

    ***When it has reached the given location, the robot needs to notify Oid that it can stop yielding.
    op [Oid:_-_|_] : Oid Location Timer -> YieldInformation [ctor] .
    ***Robot is waiting for another to have finished yielding
    op [Oid:_|_] : Oid Timer -> YieldInformation [ctor] .
    op noYieldInformation : -> YieldInformationSet [ctor] .    
    op _,_ : YieldInformationSet YieldInformationSet -> YieldInformationSet [ctor assoc comm id: noYieldInformation] .
    op addYieldInformation : Oid Location YieldInformationSet -> YieldInformationSet .
    op addYieldInformation : Oid YieldInformationSet -> YieldInformationSet .
    op getYieldTimers : YieldInformationSet -> TimerSet .
    op removeYieldInformation : Oid YieldInformationSet -> YieldInformationSet .
    op decreaseYieldTimers : YieldInformationSet Time -> YieldInformationSet .
    op yieldExpired : YieldInformation -> Bool .
    op getOid : YieldInformation -> Oid .

    op getRobots : Configuration -> Configuration .

    op water : -> Water [ctor] .
    op fertilizer : -> Fertilizer [ctor] .
    op seed : -> Seed [ctor] .
    op produce : -> Produce [ctor] .

    op needNegotiation : Object Representation Object -> Bool .
    op startNegotiation : Object Representation Object -> Configuration .
    op $timeCheck : Object Oid Time -> Object .
    op $locationChange : Object Location -> Object .
    ops $locationPrevention $speedPrevention : Object Representation -> Object .
    op crashPrevention : Object Representation -> Object .
    op safetyChecks : Object Representation Object -> Configuration .

    op detect : Configuration -> Configuration .
    op _detects_ : Object Object -> Bool .

    op remove : Oid Configuration -> Configuration .
    op _;_ : Information Information -> Information [ctor assoc comm id: noInfo] .
    op noInfo : -> Information [ctor] .
    op TaskNr:_ : Nat -> Information [ctor] .
    op detectedSpeed : Rat -> Information [ctor] .

    ops noWork : -> WorkState [ctor] .
    op [_,_,_] : Oid TaskType Time -> TimedWork [ctor] .
    ops empty full : -> CargoLevel [ctor] .

    op none : -> RepresentationSet [ctor] .
    op __ : RepresentationSet RepresentationSet -> RepresentationSet [assoc comm id: none ctor] .
    op {_:_|_} : Oid Cid Information -> Representation .
    op _notIn_ : Oid RepresentationSet -> Bool .

    op finishedResupply : Object TaskType -> Object .

    op getLocation : Object -> Location .
    op getLocation : YieldInformation -> List-Location .
    ops breaksPath $breaksPath : List-Location RepresentationSet -> Bool .
    op canCompleteNow : Object Tid -> Bool .
    op $parseTasksGL : RepresentationSet -> TidSet .
    op parseTasksGL : RepresentationSet -> TidSet .
    op assignTask : Object Tid -> Object .
    op calculatePathLength : Object Tid Object -> Rat .
    op prepareAuction : Object TidSet -> Configuration .
    ops mustRejectTask : Object -> Bool .
    op startWorkGL : Object -> Object .

    ops needsResupply needsCPoint : Object Tid -> Bool .
    ops resupplyLocCheck cPointLocCheck : Object Tid Location -> List-Location .
    op performChecks : Object Tid Configuration -> List-Location .
    op $planPathLocations : Object Tid Configuration -> List-Location .
    op $planPath : Object List-Location List-Location -> List-Location .
    op decreaseWorkTimer : Object Time -> Object .

    ***Path that robot must traverse to be able to complete task.
    ***Travels to resupply and/or collection station if needed
    op planPath : Object Tid Object -> List-Location .

    ***Adds the locations in the second list that are between locations in the first to the first list.
    op modifyPath : List-Location List-Location -> List-Location .

    op sameDestination : Location Configuration -> Configuration .
    op closest : Location Configuration Configuration -> Configuration .

    ***Checks if a given intersection has a connecting road that is not used by the list of locations.
    ***yieldLocation's boolean parameter determines if an intersection needs to have at least three connecting roads to be considered a valid solution.
    ***This is used for when a robot needs to yield to another yielding robot.
    op $yieldLocationHelper : Location RoadSet -> Location .
    op yieldLocation : Object RoadSet List-Location -> List-Location .
    ***Creates a path to the intersection that has a valid yieldLocation.
    op yieldIntersection : PQueue Object List-Location Location -> List-Location .
    op yieldPath : Object Object List-Location -> List-Location .

    ***Creates a path to the closest intersection that is connected to at least three roads.
    op conflictYieldIntersection : PQueue Object -> Object .
    op $conflictYieldPath : Configuration Object Location -> List-Location .
    op conflictYieldPath : Object Object -> List-Location .
    op $conflictYieldProtocol : Object Object Oid List-Location -> Configuration .
    op conflictYieldProtocol : Object Object Oid List-Location -> Configuration .
    ***Takes in yieldPath to determine behavior based on if one was found or not.
    op $yieldProtocol : Object Object Oid List-Location -> Configuration .
    ***Calculates yieldPath and sends result as argument to $yieldProtocol.
    op yieldProtocol : Object Object Oid List-Location -> Configuration .

    op __leadsTo_ : Location Direction Location -> Bool .
    ***Treats the location as an obstacle, and calculates the additional distance required to complete the robot's task.
    op replanCost : Object Object Location -> Cost .

    op compatibleTaskType : Object TaskType -> Bool .

    var CARGO : Cargo .
    vars CONF CONF2 : Configuration .
    vars OID OID2 OID3 OID4 : Oid .
    var OIDS : OidSet .
    vars X Y X2 Y2 X3 Y3 X4 Y4 X5 Y5 : Rat .
    vars RI RI2 : RatInf .
    var N : Nat .
    var A : Area .
    vars LL LL2 LL3 : List-Location .
    vars L L2 : Level .
    var GS : GrowingState .
    var TC : TransporterCargo .
    var RS : RoadSet .
    var MC : MsgContent .
    var CID : Cid .
    var I : Information .
    vars D D2 : Direction .
    vars SP SP2 : Rat .
    var DR : Rat .
    var STATE : State .
    var REPS : RepresentationSet .
    vars OS OS2 : OidSet .
    vars TR TR2 : Timer .
    vars TIME TIME2 : Time .
    vars TID TID2 : Tid .
    var TIDS : TidSet .
    vars AS AS2 : AttributeSet .
    var CL : CargoLevel .
    var PS : PriorityState .
    var FUNC : FunctioningState .
    var INC : IncapacitatedState .
    var PQ : PQueue .
    var O : Object . 
    var NS : NegotiationSet .
    var COST : Cost .
    var BOOL : Bool .
    var YI : YieldInformation .
    var YIS : YieldInformationSet .

    vars TT TT2 : TaskType .
    var TS : TaskStatus .
    var TPT : TransporterTask .
    var WT : WorkerTask .
    vars WS WS2 : WorkState .
    var TW : TimedWork .
    var B : Bid .    
    var AUS : AuctionSet .
    var BIS : BaseInformationSet .
    var WI : WaitingInformation .
    var TWS : TimedWorkState .

    eq getRobots(< OID : Robot | > CONF) = < OID : Robot | > getRobots(CONF) .
    eq getRobots(CONF) = none [owise] .

    eq addWaiting(noWaitingInformation, OID, (X,Y)) = [[OID - (X,Y)] | RESCAN-TIMER | WAITING-TIMER] .
    eq addWaiting([BIS | TR | TR2], OID, (X,Y)) = [BIS , [OID - (X,Y)] | TR | reset(TR2)] .
    eq getWaitingTimer(noWaitingInformation) = noTimer .
    eq getWaitingTimer([BIS | TR | TR2]) = TR TR2 .
    eq decreaseWaitingTimers(noWaitingInformation, TIME) = noWaitingInformation .
    eq decreaseWaitingTimers([BIS | TR | TR2], TIME) = [BIS | decrease(TR, TIME) | decrease(TR2, TIME)] .
    ***If a robot has moved from the last registered location or moved out of detection range it is removed from waiting on.
    eq rescanWaitingOn(([OID - (X,Y)] , BIS), < OID : Robot | location : (X,Y) > CONF) = [OID - (X,Y)] , rescanWaitingOn(BIS, CONF) .
    eq rescanWaitingOn(BIS, CONF) = noBaseInformation [owise] .
    eq [noBaseInformation | TR | TR2] = noWaitingInformation .

    eq priorityState(< OID : Robot | state : TWS, workState : TW >) = priorityWorking .
    eq priorityState(< OID : Robot | state : waiting, waitingStatus : [BIS | TR | TR2] >) = priorityWaiting .
    ceq priorityState(< OID : Robot | state : negotiating, negotiations : NS >) = priorityNegotiating if NS =/= none .
    ceq priorityState(< OID : Robot | state : FUNC, yieldStatus : YIS >) = priorityYielding if YIS =/= noYieldInformation [owise] .
    eq priorityState(< OID : Robot | state : FUNC, curTask : TID, yieldStatus : noYieldInformation >) = priorityTask [owise] .
    eq priorityState(< OID : Robot | state : idle, curTask : noTask, yieldStatus : noYieldInformation >) = priorityIdle .

    eq compatibleTaskType(< OID : Worker | >, WT) = true .
    eq compatibleTaskType(< OID : Transporter | >, TPT) = true .
    eq compatibleTaskType(< OID : Robot | >, TT) = false [owise] .

    eq remove(OID, < OID : Robot | > CONF) = CONF .
    eq remove(OID, CONF) = CONF [owise] .

    eq yieldExpired([Oid: OID - (X,Y) | TR]) = expired(TR) .
    eq yieldExpired([Oid: OID | TR]) = expired(TR) .

    eq finishedResupply(< OID : Worker | state : resupplying, curCargo : CARGO >, wateringTask) = < OID : Worker | curCargo : water, cargoLevel : full, state : idle > .
    eq finishedResupply(< OID : Worker | state : resupplying, curCargo : CARGO >, fertilizeTask) = < OID : Worker | curCargo : fertilizer, cargoLevel : full, state : idle > .
    eq finishedResupply(< OID : Worker | state : resupplying, curCargo : CARGO >, plantTask) = < OID : Worker | curCargo : seed, cargoLevel : full, state : idle > .
    eq finishedResupply(< OID : Worker | >, TT) = < OID : Worker | > [owise] .

    eq inDetectionRange(< OID : Robot | location : (X,Y), detectionRange : DR >, < OID2 : Locatable | location : (X2, Y2) > CONF) =
        < OID2 : Locatable | > inDetectionRange(< OID : Robot | >, CONF) .
    eq inDetectionRange(< OID : Robot | >, CONF) = none [owise] .

    eq replanCost(< OID : Robot | curTask : TID, obstructionPoints : LL >, < OID2 : Map | >, (X,Y)) =
        if planPath(< OID : Robot | obstructionPoints : LL (X,Y) >, TID, < OID2 : Map | >) == nil
        then
            cost(ratInf)
        else
            cost(listLength(planPath(< OID : Robot | obstructionPoints : LL (X,Y) >, TID, < OID2 : Map | >)) -
            listLength(planPath(< OID : Robot | obstructionPoints : remove(LL, (X,Y)) >, TID, < OID2 : Map | >)))
        fi .

    ***Don'DR apply safety checks if the robot is moving.
    ceq safetyChecks(< OID : Robot | state : STATE >, {OID2 : Robot | I}, < OID3 : Map | >) = < OID : Robot | > if STATE =/= moving .
    eq safetyChecks(< OID : Robot | >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >) =
        if needNegotiation(< OID : Robot | >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >)
        then
            startNegotiation(< OID : Robot | >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >)
        else
            crashPrevention(< OID : Robot | >, {OID2 : Robot | FUNC ; I})
        fi .
    ***Crash prevention consists of changing speed and/or the remaining path if relevant.
    eq crashPrevention(< OID : Robot | location : (X,Y), remainingPath : LL >, {OID2 : CID | (X2,Y2) ; I}) = 
        if between((X2, Y2), (X,Y) LL) =/= nil
        then
            $speedPrevention($locationPrevention(< OID : Robot | >, {OID2 : CID | (X2,Y2) ; I}), {OID2 : CID | (X2,Y2) ; I})
        else
            < OID : Robot | >
        fi .

    ***Location change is only performed when detecting an immobile object.
    ***If the task is to fix the robot, then we are not waiting on it, but otherwise we are.
    ***ceq $locationPrevention(< OID : Robot | waitingStatus : OS >, {OID2 : Robot | (X2,Y2) ; FUNC ; I}) = if STATE =/= moving .
    eq $locationPrevention(< OID : Robot | >, {OID2 : Robot | moving ; I}) = < OID : Robot | > .
    eq $locationPrevention(< OID : Robot | location : (X,Y), remainingPath : LL >, {OID2 : Robot | (X2,Y2) ; INC ; I}) = $locationChange(< OID : Robot | remainingPath : (X,Y) LL >, (X2,Y2)) .
    eq $locationPrevention(< OID : Robot | location : (X,Y), remainingPath : LL >, {OID2 : Obstacle | (X2,Y2)}) = $locationChange(< OID : Robot | remainingPath : (X,Y) LL >, (X2,Y2)) .
 
    eq $locationChange(< OID : Robot | remainingPath : LL (X,Y) (X,Y2) >, (X,Y2)) =
        if Y > Y2
        then
            < OID : Robot | remainingPath : LL (X,Y) (X,Y2 + ROBOT-SIZE) >
        else
            < OID : Robot | remainingPath : LL (X,Y) (X,Y2 - ROBOT-SIZE) >
        fi .
    eq $locationChange(< OID : Robot | remainingPath : LL (X,Y) (X2,Y) >, (X2,Y)) =
        if X > X2
        then
            < OID : Robot | remainingPath : LL (X,Y) (X2 + ROBOT-SIZE,Y) >
        else
            < OID : Robot | remainingPath : LL (X,Y) (X2 - ROBOT-SIZE,Y) >
        fi .

    ***Only location change is needed here to prevent the Robot's path from overlapping with the obstacle.
    ***Speed change is dependent on the time it would take until the robot would crash with the detected object.
    eq $speedPrevention(< OID : Robot | >, {OID2 : Obstacle | I}) = < OID : Robot | > .
    eq $speedPrevention(< OID : Robot | location : (X,Y), direction : D, speed : SP >, {OID2 : Robot | (X2,Y2) ; D ; detectedSpeed(SP2) ; moving ; I}) =
        if SP2 >= SP
        then
            < OID : Robot | >
        else
            $timeCheck(< OID : Robot | >, OID2, distance((X,Y), (X2,Y2)) / (SP - SP2))
        fi .
    ceq $speedPrevention(< OID : Robot | location : (X,Y), direction : D, speed : SP >, {OID2 : Robot | (X2, Y2) ; D2 ; detectedSpeed(SP2) ; moving ; I}) =
        $timeCheck(< OID : Robot | >, OID2, distance((X,Y), (X2,Y2)) / (SP + SP2))
        if oppositeDirections(D, D2) .
    eq $speedPrevention(< OID : Robot | >, {OID2 : Robot | I}) = < OID : Robot | > [owise] .

    ***Modifies the robot's speed based on the calculated time until crash.
    eq $timeCheck(< OID : Robot | >, OID2, TIME) =
        if TIME < EMERGENCY-TIME
        then
            < OID : Robot | state : idle, speed : 0 >
        else
            if TIME < SAFE-TIME 
            then
                < OID : Robot | speed : SAFE-SPEED >
            else
                < OID : Robot | >
            fi
        fi .

    ceq (X,Y) north leadsTo (X,Y2) = true if Y2 > Y .
    ceq (X,Y) south leadsTo (X,Y2) = true if Y2 < Y .
    ceq (X,Y) east leadsTo (X2,Y) = true if X2 > X .
    ceq (X,Y) west leadsTo (X2,Y) = true if X2 < X .
    eq (X,Y) D leadsTo (X2,Y2) = false [owise] .

    ceq needNegotiation(< OID : Robot | negotiations : NS >, {OID2 : Robot | I}, < OID3 : Map | >) =
        false if inNegotiationSet(NS, OID2) .
    ***Need to start negotation if two robots move towards each other directly, without any intersection in the middle.
    ceq needNegotiation(< OID : Robot | location : (X,Y), direction : D, state : moving, negotiations : NS >,
        {OID2 : Robot | (X2,Y2) ; D2 ; moving ; I}, < OID3 : Map | roads : {(X3,Y3) (X4,Y4)} RS >) =
            true if oppositeDirections(D,D2) and (findRoad((X,Y), {(X3,Y3) (X4,Y4)}) == findRoad((X2,Y2), {(X3,Y3) (X4,Y4)}))
            and not inNegotiationSet(NS, OID2) .
    ***If a robot is moving towards a stationary robot that is in the way.
    ceq needNegotiation(< OID : Robot | location : (X,Y), remainingPath : LL, state : moving, negotiations : NS >,
        {OID2 : Robot | (X2,Y2) ; STATE ; I}, < OID3 : Map | roads : RS >) =
            true if (STATE =/= moving) and (between((X2,Y2), (X,Y) LL) =/= nil)
            and not inNegotiationSet(NS, OID2) .
    ***two robots move towards the same intersection from different paths.
    ceq needNegotiation(< OID : Robot | location : (X,Y), state : moving, direction : D, negotiations : NS >,
        {OID2 : Robot | (X2,Y2) ; D2 ; moving ; I}, < OID3 : Map | roads : {(X3,Y3) (X4,Y4)} {(X4, Y4) (X5,Y5)} RS >) =
            true if (X,Y) inRange({(X3,Y3) (X4,Y4)}) and (X2,Y2) inRange({(X4, Y4) (X5,Y5)})
            and ((X,Y) D leadsTo (X4,Y4)) and ((X2,Y2) D2 leadsTo (X4,Y4))
            and not inNegotiationSet(NS, OID2) .
    eq needNegotiation(< OID : Robot | >, {OID2 : Robot | I}, < OID3 : Map | >) = false [owise] .

    eq startNegotiation(< OID : Robot | location : (X,Y), remainingPath : LL, negotiations : NS >, {OID2 : Robot | (X2,Y2) ; I}, < OID3 : Map | >) =
        < OID : Robot | state : negotiating, speed : 0, negotiations : addNegotiation(NS, [OID2 | (X2,Y2) | noCost]) > 
        dly(msg requestPath & path((X,Y) LL) & priorityState(< OID : Robot | >) from OID to OID2, MSG-DELAY) .

    eq closest((X,Y), CONF, none) = CONF .
    eq closest((X,Y), < OID : Robot | location : (X2,Y2), direction : D > CONF, < OID2 : Robot | location : (X3,Y3), direction : D > CONF2) =
        if distance((X,Y), (X2,Y2)) < distance((X,Y), (X3,Y3))
        then
            closest((X,Y), < OID : Robot | > CONF, CONF2)
        else
            closest((X,Y), < OID2 : Robot | > CONF, CONF2)
        fi .
    eq closest((X,Y), CONF, < OID : Robot | > CONF2) = closest((X,Y), < OID : Robot | > CONF, CONF2) .
    
    eq sameDestination((X,Y), < OID : Robot | remainingPath : (X,Y) LL > CONF) = < OID : Robot | > sameDestination((X,Y), CONF) .
    eq sameDestination((X,Y), CONF) = none [owise] .

    eq getLocation(< OID : Robot | location : (X,Y) >) = (X,Y) .
    eq getLocation([Oid: OID - (X,Y) | TR]) = (X,Y) .
    eq getLocation(YI) = nil [owise] .

    eq getYieldTimers(([Oid: OID - (X,Y) | TR] , YIS)) = TR getYieldTimers(YIS) .
    eq getYieldTimers(([Oid: OID | TR] , YIS)) = TR getYieldTimers(YIS) .
    eq getYieldTimers(noYieldInformation) = noTimer .

    eq decreaseYieldTimers(([Oid: OID - (X,Y) | TR] , YIS), TIME) = [Oid: OID - (X,Y) | decrease(TR, TIME)] , decreaseYieldTimers(YIS, TIME) .
    eq decreaseYieldTimers(([Oid: OID | TR] , YIS), TIME) = [Oid: OID | decrease(TR, TIME)] , decreaseYieldTimers(YIS, TIME) .
    eq decreaseYieldTimers(noYieldInformation, TIME) = noYieldInformation .

    eq decreaseWorkTimer(< OID : Robot | workState : [OID2, (removeAt (X,Y)), TIME] >, TIME2) = < OID : Robot | workState : [OID2, (removeAt (X,Y)), (TIME monus TIME2)] > .
    eq decreaseWorkTimer(< OID : Robot | workState : [OID2, (repairAt (X,Y)), TIME] >, TIME2) = < OID : Robot | workState : [OID2, (repairAt (X,Y)), (TIME monus TIME2)] > .
    eq decreaseWorkTimer(< OID : Robot | workState : [OID2, resupplyTask, TIME] >, TIME2) = < OID : Robot | workState : [OID2, resupplyTask, (TIME monus TIME2)] > .
    eq decreaseWorkTimer(< OID : Robot | workState : [OID2, unloadTask, TIME] >, TIME2) = < OID : Robot | workState : [OID2, unloadTask, (TIME monus TIME2)] > .
    eq decreaseWorkTimer(< OID : Robot | >, TIME) = < OID : Robot | > [owise] .

    eq decreaseTimers(< OID : Robot | auctions : AUS, yieldStatus : YIS, waitingStatus : WI >, TIME) = 
        decreaseWorkTimer(< OID : Robot | auctions : decreaseAuctionTimers(AUS, TIME), yieldStatus : decreaseYieldTimers(YIS, TIME), waitingStatus : decreaseWaitingTimers(WI, TIME) >, TIME) .

    eq mustRejectTask(< OID : Robot | state : INC >) = true .
    eq mustRejectTask(< OID : Robot | curTask : TID >) = true .
    eq mustRejectTask(< OID : Robot | >) = false [owise] .

    eq needsCPoint(< OID : Worker | >, TID) = false .
    eq needsCPoint(< OID : Transporter | cargoLevel : CL >, TID) = CL == full .

    ceq removeYieldInformation(OID, (YI ,YIS)) = YIS if getOid(YI) == OID .
    eq removeYieldInformation(OID, YIS) = YIS [owise] .

    ceq needsResupply(< OID : Worker | curCargo : CARGO >, [OID2, wateringTask]) = true if CARGO =/= water .
    ceq needsResupply(< OID : Worker | curCargo : CARGO >, [OID2, fertilizeTask]) = true if CARGO =/= fertilizer .
    ceq needsResupply(< OID : Worker | curCargo : CARGO >, [OID2, plantTask]) = true if CARGO =/= seed .
    eq needsResupply(< OID : Worker | cargoLevel : empty >, TID) = true .
    eq needsResupply(< OID : Robot | >, TID) = false [owise] .

    eq cPointLocCheck(< OID : Robot | >, TID, (X,Y)) = if needsCPoint(< OID : Robot | >, TID) then (X,Y) else nil fi .

    eq resupplyLocCheck(< OID : Robot | >, TID, (X,Y)) = if needsResupply(< OID : Robot | >, TID) then (X,Y) else nil fi .

    eq performChecks(< OID : Robot | >, TID, < OID2 : ResupplyStation | location : (X,Y) > < OID3 : CollectionStation | location : (X2,Y2) > CONF) =
        resupplyLocCheck(< OID : Robot | >, TID, (X,Y)) cPointLocCheck(< OID : Robot | >, TID, (X2,Y2)) .

    ceq canCompleteNow(< OID : Worker | state : FUNC, curTask : TS >, [OID2, removeAt (X,Y)]) = true if (TS == noTask) or (TS == [OID2, removeAt (X,Y)]) .
    ceq canCompleteNow(< OID : Worker | state : FUNC, curTask : TS >, [OID2, repairAt (X,Y)]) = true if (TS == noTask) or (TS == [OID2, repairAt (X,Y)]) .
    eq canCompleteNow(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : water >, [OID2, wateringTask]) = true .
    eq canCompleteNow(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : fertilizer >, [OID2, fertilizeTask]) = true .
    eq canCompleteNow(< OID : Worker | state : FUNC, cargoLevel : full, curCargo : seed >, [OID2, plantTask]) = true .
    eq canCompleteNow(< OID : Transporter | state : FUNC, cargoLevel : empty >, [OID2, harvestTask]) = true .
    eq canCompleteNow(< OID : Robot | state : INC >, TID) = false .
    ceq canCompleteNow(< OID : Robot | curTask : TID >, TID2) = false if TID =/= noTask .
    eq canCompleteNow(< OID : Robot | >, TID) = false [owise] .

    eq calculatePathLength(< OID : Robot | >, TID, < OID2 : Map | >) = listLength(planPath(< OID : Robot | >, TID, < OID2 : Map | >)) .

    ***Returns the locations the robot must visit on its path to complete the task.
    eq $planPathLocations(< OID : Robot | location : (X,Y) >, [OID2, TT], < OID2 : Locatable | location : (X2,Y2) > CONF) =
        (X,Y) performChecks(< OID : Robot | >, [OID2, TT], < OID2 : Locatable | location : (X2,Y2) > CONF) (X2,Y2) .

    eq $planPath(< OID : Map | >, LL, LL2) = dijkstraChain(getIntersections(modifyMap(< OID : Map | >, LL, LL2)), LL) .

    eq planPath(< OID : Robot | location : (X,Y), obstructionPoints : LL >, [OID2, TT], < OID3 : Map | allIntersections : CONF >) =
        removeNeighborDuplicates(
            $planPath(< OID3 : Map | >,
                $planPathLocations(< OID : Robot | >, [OID2, TT], CONF),
                LL
            )
        ) .

    ceq modifyPath(LL (X,Y) (X2,Y2) LL2, (X3,Y3) LL3) = modifyPath(LL (X,Y) (X3,Y3) (X2,Y2) LL2, LL3)
        if ((X3,Y3) =/= (X,Y) and (X3,Y3) =/= (X2,Y2) and between((X3,Y3), (X,Y) (X2,Y2)) =/= nil) . 
    eq modifyPath(LL, LL2) = LL [owise] .

    eq OID notIn ({OID : CID | (X,Y) ; I} REPS) = false .
    eq OID notIn REPS = true [owise] .
    ceq $breaksPath((X,Y) (X,Y2), {OID2 : CID | (X,Y3) ; north ; I}) = true if Y > Y2 .
    ceq $breaksPath((X,Y) (X2,Y), {OID2 : CID | (X3,Y) ; east ; I}) = true if X > X2 .
    ceq $breaksPath((X,Y) (X,Y2), {OID2 : CID | (X,Y3) ; south ; I}) = true if Y < Y2 .
    ceq $breaksPath((X,Y) (X2,Y), {OID2 : CID | (X3,Y) ; west ; I}) = true if X < X2 .
    eq $breaksPath(LL, REPS) = false [owise] .
    
    ceq breaksPath(LL, {OID2 : CID | (X,Y) ; I}) = false if between((X,Y), LL) == nil .
    eq breaksPath(LL, {OID2 : Obstacle | (X,Y) ; I}) =
        if between((X,Y), LL) == nil then
            false
        else
            true
        fi .
    eq breaksPath(LL, {OID2 : CID | (X,Y) ; D ; I}) = $breaksPath(between((X,Y), LL), {OID2 : CID | (X,Y) ; D ; I}) .

    eq $yieldLocationHelper((X,Y), {(X,Y) (X,Y2)} RS) =
        if Y < Y2
        then
            (X, Y + YIELD-GAP)
        else
            (X, Y - YIELD-GAP)
        fi .
    eq $yieldLocationHelper((X,Y), {(X,Y) (X2,Y)} RS) =
        if X < X2
        then
            (X + YIELD-GAP, Y)
        else
            (X - YIELD-GAP, Y)
        fi .

    eq yieldLocation(< OID : PassIntersection | location : (X,Y) >, RS, LL (X,Y) LL2) =
        if findRoad((X,Y), RS) \ findRoad(last(LL) first(LL2), RS) =/= es then
            $yieldLocationHelper((X,Y), findRoad((X,Y), RS) \ findRoad(last(LL) first(LL2), RS))
        else
            nil
        fi .
    eq yieldLocation(< OID : Intersection | >, RS, LL) = nil [owise] .
        
    eq yieldIntersection([< OID : PassIntersection | location : (X,Y) >, 0, "Start"] PQ, < OID2 : Map | roads : RS >, LL, (X,Y)) = 
        if yieldLocation(< OID : PassIntersection | >, RS, LL) =/= nil
        then
            yieldLocation(< OID : PassIntersection | >, RS, LL)
        else
            if size(findRoad((X,Y), RS)) == 1
            then
                nil
            else
                yieldIntersection(PQ, < OID2 : Map | >, LL, (X,Y))
            fi
        fi .
    ceq yieldIntersection([< OID : PassIntersection | location : (X,Y) >, RI, OID2] PQ, < OID3 : Map | allIntersections : CONF, roads : RS >, LL, (X2,Y2)) =
        if RI == ratInf
        then
            nil
        else
            if yieldLocation(< OID : PassIntersection | >, RS, LL) =/= nil
            then
                if not pathConflict(dijkstraSearch(CONF, (X2,Y2), (X,Y)), LL)
                then
                    dijkstraSearch(CONF, (X2,Y2), (X,Y)) yieldLocation(< OID : PassIntersection | >, RS, LL)
                else
                    yieldIntersection(PQ, < OID3 : Map | >, LL, (X2,Y2))
                fi
            else
                yieldIntersection(PQ, < OID3 : Map | >, LL, (X2,Y2))
            fi
        fi
        if OID2 =/= "Start" .
    eq yieldIntersection(noQueue, < OID : Map | >, LL, (X,Y)) = nil .

    eq yieldPath(< OID : Robot | location : (X,Y), obstructionPoints : LL >, < OID2 : Map | >, LL2) =
        yieldIntersection(
            updateDistances(PQConvert(getIntersections(modifyMap(< OID2 : Map | >, (X,Y) LL2, LL)), (X,Y))),
            modifyMap(< OID2 : Map | >, (X,Y) LL2, LL),
            modifyPath(LL2, (X,Y)),
            (X,Y)
        ) .

    ***valid yieldIntersection has at least 3 connected roads.
    eq conflictYieldIntersection([< OID : PassIntersection | location : (X,Y) >, RI, OID2] PQ, < OID3 : Map | roads : RS >) =
        if RI == ratInf
        then
            none
        else
            if size(findRoad((X,Y), RS)) > 2
            then
                < OID : PassIntersection | >
            else
                conflictYieldIntersection(PQ, < OID3 : Map | >)
            fi
        fi .
        
    eq $conflictYieldPath(< OID : PassIntersection | location : (X,Y) >, < OID2 : Map | allIntersections : CONF, roads : RS >, (X2,Y2)) =
        dijkstraSearch(CONF, (X2,Y2), (X,Y)) yieldLocation(< OID : PassIntersection | >, RS, dijkstraSearch(CONF, (X2,Y2), (X,Y))) .

    eq $conflictYieldPath(none, < OID2 : Map | >, (X2,Y2)) = nil .

    eq conflictYieldPath(< OID : Robot | location : (X,Y), obstructionPoints : LL >, < OID2 : Map | >) =
        $conflictYieldPath(
            conflictYieldIntersection(
                updateDistances(PQConvert(getIntersections(modifyMap(< OID2 : Map | >, (X,Y), LL)), (X,Y))),
                modifyMap(< OID2 : Map | >, (X,Y), LL)
            ),
            modifyMap(< OID2 : Map | >, (X,Y), LL),
            (X,Y)
        ) .

    eq $yieldProtocol(< OID : Robot | remainingPath : LL >, < OID2 : Map | >, OID3, nil) =
        < OID : Robot | remainingPath : conflictYieldPath(< OID : Robot | >, < OID2 : Map | >) >
        dly(msg conflictYield(conflictYieldPath(< OID : Robot | >, < OID2 : Map | >)) from OID to OID3, MSG-DELAY) .

    eq $yieldProtocol(< OID : Robot | negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, LL (X,Y) (X2,Y2)) =
        < OID : Robot | remainingPath : LL (X,Y) (X2,Y2), negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInformation(OID3, YIS) >
        dly(msg yielding (X,Y) from OID to OID3, MSG-DELAY) .

    eq $yieldProtocol(< OID : Robot | location : (X,Y), negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, (X2,Y2)) =
        < OID : Robot | remainingPath : (X2,Y2), negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInformation(OID3, YIS) >
        dly(msg yielding (X,Y) from OID to OID3, MSG-DELAY) .

    eq $conflictYieldProtocol(< OID : Robot | state : STATE, negotiations : NS >, < OID2 : Map | >, OID3, nil) =
        < OID : Robot | state : deadlocked, negotiations : endNegotiation(NS, OID3) >
        dly(msg noYield from OID to OID3, MSG-DELAY) .
    
    eq $conflictYieldProtocol(< OID : Robot | negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, LL (X,Y) (X2,Y2)) =
        < OID : Robot | remainingPath : LL (X,Y) (X2,Y2), negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInformation(OID3, YIS) >
        dly(msg yielding (X,Y) from OID to OID3, MSG-DELAY) .

    eq conflictYieldProtocol(< OID : Robot | location : (X,Y) >, < OID2 : Map | >, OID3, LL) =
        $conflictYieldProtocol(< OID : Robot | >, < OID2 : Map | >, OID3, yieldPath(< OID : Robot | >, < OID2 : Map | >, LL)) .

    ***Robot moves out of way of LL.
    eq yieldProtocol(< OID : Robot | location : (X,Y), remainingPath : LL, negotiations : NS, yieldStatus : YIS >, < OID2 : Map | >, OID3, LL2) =
        if not pathConflict((LL2), (X,Y))
        then
            < OID : Robot | remainingPath : nil, negotiations : endNegotiation(NS, OID3), yieldStatus : addYieldInformation(OID3, YIS) >
            dly(msg yielding sharedLocation((X,Y) LL, LL2) from OID to OID3, MSG-DELAY)
        else
            $yieldProtocol(< OID : Robot | >, < OID2 : Map | >, OID3, yieldPath(< OID : Robot | >, < OID2 : Map | >, LL2))
        fi .

    eq addYieldInformation(OID, (X,Y), ([Oid: OID - (X2,Y2) | TR] , YIS)) =
        [Oid: OID - (X,Y) | YIELD-TIMER] , YIS .
    eq addYieldInformation(OID, (X,Y), YIS) =
        [Oid: OID - (X,Y) | YIELD-TIMER] , YIS [owise] .
    eq addYieldInformation(OID, ([Oid: OID | TR] ,YIS)) = 
        [Oid: OID | YIELD-TIMER] , YIS .
    eq addYieldInformation(OID, YIS) =
        [Oid: OID | YIELD-TIMER] , YIS [owise] .

    eq getOid([Oid: OID - (X,Y) | TR]) = OID .
    eq getOid([Oid: OID | TR]) = OID .

    eq < OID : Robot | curTask : [OID2, TT] > detects < OID2 : Locatable | > = false .
    eq < OID : Robot | obstructionPoints : (X,Y) LL > detects < OID2 : Locatable | location : (X,Y) > = false .
    eq < OID : Robot | location : (X,Y), detected : REPS, detectionRange : DR > detects < OID2 : Locatable | location : (X2,Y2) > = (OID2 notIn REPS) and distance((X,Y), (X2,Y2)) <= DR .
    eq < OID : Robot | > detects < OID2 : Locatable | > = true [owise] .

    ceq detect(< OID : Robot | state : FUNC, detected : REPS > < OID2 : Obstacle | location : (X2,Y2) > CONF) =
        detect(< OID : Robot | detected : {OID2 : Obstacle | (X2,Y2)} REPS > < OID2 : Obstacle | > CONF) if < OID : Robot | > detects < OID2 : Obstacle | > .
    ceq detect(< OID : Robot | detected : REPS, workState : WS > < OID2 : Robot | state : STATE, location : (X2,Y2), direction : D, speed : SP, workState : WS2 > CONF) =
        detect(< OID : Robot | detected : {OID2 : Robot | (X2,Y2) ; D ; detectedSpeed(SP) ; STATE} REPS > < OID2 : Robot | > CONF) if (< OID : Robot | > detects < OID2 : Robot | >) .
    eq detect(CONF) = CONF [owise] .

    ***Do a detection before starting to travel.
    ***maybe change how detect works. Instead of doing all, it does one at a time, so I can check result
    ***add that detection must be empty to prevent looping
    ***but it may still loop, update detection, parse them try to start travel, update detection.

    rl [startTravel] :
        < OID : Robot | location : (X,Y), remainingPath : (X2,Y2) LL, state : idle, speed : 0, maxSpeed : SP, detected : none, negotiations : none >
        =>
        if (X,Y) == (X2,Y2)
        then
            < OID : Robot | remainingPath : LL >
        else
            < OID : Robot | state : moving, direction : setDirection((X,Y), (X2,Y2)), speed : SP >
        fi .

    crl [rescanTimerExpire] :
        < OID : Robot | waitingStatus : [BIS | TR | TR2] >
        CONF
        =>
        < OID : Robot | waitingStatus : [rescanWaitingOn(BIS, inDetectionRange(< OID : Robot | >, CONF)) | reset(TR) | TR2] >
        CONF
        if expired(TR) .
    
    crl [waitingTimerExpire] :
        < OID : Robot | waitingStatus : [BIS | TR | TR2] >
        =>
        < OID : Robot | waitingStatus : noWaitingInformation >
        if expired(TR2) .
    
    ***Another robot tells us to wait on it, add it to waitingInformation.
    crl [rcvPriorityWaitingMsg] :
        < OID : Robot | location : (X,Y), remainingPath : LL, waitingStatus : WI, negotiations : NS >
        msg priorityWaiting & path((X2,Y2) LL2) from OID2 to OID
        =>
        < OID : Robot | waitingStatus : addWaiting(WI, OID2, (X2,Y2)), negotiations : endNegotiation(NS, OID2) >
        if pathConflict((X,Y) LL, (X2,Y2)) .

    crl [yieldTimerExpire] :
        < OID : Robot | yieldStatus : YI , YIS >
        =>
        < OID : Robot | yieldStatus : YIS >
        if yieldExpired(YI) .

    rl [finishWaiting] : 
        < OID : Robot | state : waiting, waitingStatus : noWaitingInformation, negotiations : NS >
        =>
        if NS == none
        then
            < OID : Robot | state : idle >
        else
            < OID : Robot | state : negotiating >
        fi .
        
    rl [rcvWonMsg] :
        < OID : Robot | >
        msg won TID from OID2 to OID
        =>
        if mustRejectTask(< OID : Robot | >)
        then
            < OID : Robot | >
            dly(msg reject TID from OID to OID2, MSG-DELAY)
        else
            < OID : Robot | state : planningPath, speed : 0, curTask : TID >
            dly(msg accept TID from OID to OID2, MSG-DELAY)
        fi .
    
    ***A robot that has a task and is not involved in resolving a conflict will path towards task.
    rl [restartTask] :
        < OID : Robot | state : idle, remainingPath : nil, yieldStatus : noYieldInformation, curTask : TID >
        =>
        < OID : Robot | state : planningPath > .

    ***If a robot receives a higher cost message it will reroute.
    crl [rcvHigherCostMsg] :
        < OID : Robot | state : FUNC, obstructionPoints : LL, negotiations : NS [OID2 | (X,Y) | cost(RI)], curTask : TID >
        < OID3 : Map | >
        msg path((X2,Y2) LL2) & pathCost(cost(RI2)) from OID2 to OID
        =>
        < OID : Robot | state : planningPath, obstructionPoints : (X2,Y2) LL, negotiations : NS >
        < OID3 : Map | >
        dly(msg noConflict from OID to OID2, MSG-DELAY)
        if RI2 > RI .

    rl [rcvEqualCostMsg] :
        < OID : Robot | state : FUNC, obstructionPoints : LL, negotiations : NS [OID2 | (X,Y) | cost(RI)], curTask : TID >
        < OID3 : Map | > 
        msg path((X2,Y2) LL2) & pathCost(cost(RI)) from OID2 to OID
        =>
        ***If both costs are ratInf, the conflict is not solvable with rerouting.
        ***Start the yielding process to check if the conflict can be solved with one of the robots yielding.
        if RI == ratInf
        then
            if OID < OID2
            then
                ***attempt to yield to the path
                ***If we find one, then we can yield and send yielding back
                ***If we cant, do conflict yield, and if there is no yield?
                ***Since we know both receive the cost, we know other robot is doing same calculation, so we can send noyield.
                yieldProtocol(
                    < OID : Robot | state : negotiating, speed : 0, negotiations : addNegotiation(NS, [OID2 | (X2,Y2) | cost(RI)]) >,
                    < OID3 : Map | >,
                    OID2,
                    (X2,Y2) LL2
                )
                < OID3 : Map | >
            else
                < OID : Robot | >
                < OID3 : Map | >
            fi
        else
            if OID < OID2
            then
                < OID : Robot | state : planningPath, obstructionPoints : (X2,Y2) LL, negotiations : NS >
                < OID3 : Map | > 
                dly(msg noConflict from OID to OID2, MSG-DELAY)
            else
                < OID : Robot | >
                < OID3 : Map | > 
            fi 
        fi .


    ***If a robot receives a lower cost message, it knows that the other should reroute
    ***It therefore does not change beavior
    crl [rcvLowerCostMsg] :
        < OID : Robot | negotiations : NS [OID2 | (X,Y) | cost(RI)] >
        msg path(LL) & pathCost(cost(RI2)) from OID2 to OID
        =>
        < OID : Robot | >
        if RI < RI2  .

    crl [rcvInvalidCost] :
        < OID : Robot | negotiations : NS >
        msg path(LL) & pathCost(COST) from OID2 to OID
        =>
        < OID : Robot | >
        if not inNegotiationSet(NS, OID2) .
        
    rl [rcvNoConflictMsg] :
        < OID : Robot | negotiations : NS >
        msg noConflict from OID2 to OID
        =>
        < OID : Robot | negotiations : endNegotiation(NS, OID2) > .

    rl [rcvYieldingMsg] :
        < OID : Robot | negotiations : NS, yieldStatus : YIS >
        msg yielding (X,Y) from OID2 to OID
        =>
        < OID : Robot | negotiations : endNegotiation(NS, OID2), yieldStatus : addYieldInformation(OID2, (X,Y), YIS) > .

    crl [rcvConflictYieldHigherPriority] :
        < OID : Robot | location : (X,Y), remainingPath : LL, state : negotiating, negotiations : NS >
        < OID2 : Map | >
        msg conflictYield(LL2) from OID3 to OID
        =>
        < OID : Robot | negotiations : endNegotiation(NS, OID3) >
        < OID2 : Map | >
        dly(msg priorityWaiting & path((X,Y) LL) from OID to OID3, MSG-DELAY)
        if priorityState(< OID : Robot | >) == priorityWaiting
            or priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID3) >) == priorityNegotiating .
    
    crl [rcvConflictYield] :
        < OID : Robot | state : negotiating, negotiations : NS >
        < OID2 : Map | >
        msg conflictYield(LL2) from OID3 to OID
        =>
        conflictYieldProtocol(< OID : Robot | >, < OID2 : Map | >, OID3, LL2)
        < OID2 : Map | >
        if priorityState(< OID : Robot | >) =/= priorityWaiting and
            priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID3) >) =/= priorityNegotiating .

    rl [rcvNoYield] :
        < OID : Robot | negotiations : NS >
        msg noYield from OID2 to OID
        =>
        < OID : Robot | state : deadlocked, negotiations : endNegotiation(NS, OID2) > .

    ***when planning path, if it is not possible, then auction away tasks.
    rl [planPath] :
        < OID : Robot | state : planningPath, detected : none, curTask : TID >
        < OID3 : Map | >
        CONF
        =>
        if planPath(< OID : Robot | >, TID, < OID3 : Map | >) == nil
        then
            initiateAuction(< OID : Robot | state : idle, remainingPath : nil > , TID, CONF)
            < OID3 : Map | >
            CONF
        else
            < OID : Robot | state : idle, remainingPath : planPath(< OID : Robot | >, TID, < OID3 : Map | >) >
            < OID3 : Map | >
            CONF
        fi .

    ***Notify another robot when Self has reached the yieldIntersection, Other can move again.
    rl [finishYieldingTask] :
        < OID : Robot | state : FUNC, location : (X,Y), yieldStatus : ([Oid: OID2 - (X,Y) | TR], YIS) >
        < OID2 : Robot | >
        < OID3 : Map | >
        =>
        < OID : Robot | state : FUNC, yieldStatus : YIS >
        < OID2 : Robot | >
        < OID3 : Map | >
        dly(msg completedYield from OID to OID2, MSG-DELAY) .

    crl [rcvPathNegotiationNoConflict] :
        < OID : Robot | location : (X,Y), state : STATE, remainingPath : LL >
        msg requestPath & path(LL2) & PS from OID2 to OID
        =>
        < OID : Robot | >
        dly(msg noConflict from OID to OID2, MSG-DELAY)
        if ((not pathConflict(LL2, (X,Y) LL)) and STATE == moving) or  ((not pathConflict(LL2, (X,Y))) and STATE =/= moving) .

    crl [rcvPathNegotiationIdle] :
        < OID : Robot | location : (X,Y), negotiations : NS >
        < OID2 : Map | >
        msg requestPath & path((X2,Y2) LL) & PS from OID3 to OID
        =>
        yieldProtocol(
            < OID : Robot | state : negotiating, speed : 0, negotiations : addNegotiation(NS, [OID3 | (X2,Y2) | noCost]) >,
            < OID2 : Map | >,
            OID3,
            (X2,Y2) LL
        )
        < OID2 : Map | >
        if pathConflict((X2,Y2) LL, (X,Y)) and priorityState(< OID : Robot | >) == priorityIdle .

    crl [rcvPathNegotiationHighestPriority] :
        < OID : Robot | location : (X,Y), remainingPath : LL, negotiations : NS >
        msg requestPath & path(LL2) & PS from OID2 to OID
        =>
        < OID : Robot | >
        dly(msg path((X,Y) LL) & priorityWaiting from OID to OID2, MSG-DELAY)
        if pathConflict(LL2, (X,Y))
            and (priorityState(< OID : Robot | >) == priorityWorking
            or priorityState(< OID : Robot | >) == priorityWaiting
            or priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID2) >) == priorityNegotiating) .

    crl [rcvPathNegotiationTask] :
        < OID : Robot | location : (X,Y), remainingPath : LL, negotiations : NS >
        < OID2 : Map | >
        msg requestPath & path((X2,Y2) LL2) & PS from OID3 to OID
        =>
        if PS == priorityTask
        then
            < OID : Robot | state : negotiating, speed : 0, negotiations : addNegotiation(NS, [OID3 | (X2,Y2) | replanCost(< OID : Robot | >, < OID2 : Map | >, (X2, Y2))]) >
            < OID2 : Map | >
            dly(msg path((X,Y) LL) & pathCost(replanCost(< OID : Robot | >, < OID2 : Map | >, (X2, Y2))) from OID to OID3, MSG-DELAY)
        else
            yieldProtocol(
                < OID : Robot | state : negotiating, speed : 0, negotiations : addNegotiation(NS, [OID3 | (X2,Y2) | noCost]) >,
                < OID2 : Map | >,
                OID3,
                (X2,Y2) LL2
            )
            < OID2 : Map | >
        fi
        if pathConflict((X2,Y2) LL2, (X,Y) LL) and priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID3) >) == priorityTask .

    ***TODO: Fix yielding towards same intersection.
    crl [rcvPathNegotiationYielding] : 
        < OID : Robot | location : (X,Y), remainingPath : LL, negotiations : NS >
        < OID2 : Map | >
        msg requestPath & path((X2,Y2) LL2) & PS from OID3 to OID
        =>
        if PS == priorityYielding
        then
            ***Tiebreaker, lowest oid maintains, other yields.
            if OID < OID3
            then
                if LL == nil
                then
                    < OID : Robot | >
                    < OID2 : Map | >
                    dly(msg priorityWaiting & path((X,Y)) from OID to OID3, MSG-DELAY)
                else
                    < OID : Robot | >
                    < OID2 : Map | >
                fi
            else
                yieldProtocol(
                    < OID : Robot | state : negotiating, speed : 0, negotiations : addNegotiation(NS, [OID3 | (X2,Y2) | noCost]) >,
                    < OID2 : Map | >,
                    OID3,
                    (X2,Y2) LL2
                )
                < OID2 : Map | >
            fi
        else
            if pathConflict((X,Y) LL, (X2,Y2) LL2)
            then
                < OID : Robot | >
                < OID2 : Map | >
                dly(msg requestPath & path(LL) & priorityYielding from OID to OID3, MSG-DELAY)
            else
                < OID : Robot | >
                < OID2 : Map | >
                dly(msg path((X,Y) LL) & priorityWaiting from OID to OID3, MSG-DELAY)
            fi
        fi
        if priorityState(< OID : Robot | negotiations : endNegotiation(NS, OID3) >) == priorityYielding
        and pathConflict((X2,Y2) LL2, (X,Y) LL) .

    rl [rcvCompletedYieldingMsg] :
        < OID : Robot | state : FUNC, yieldStatus : YIS >
        msg completedYield from OID2 to OID
        =>
        < OID : Robot  | yieldStatus : removeYieldInformation(OID2, YIS) > .

    ***Workers discard transporter tasks
    rl [rcvWrongWorkerTask] :
        < OID : Worker | >
        msg [OID2, TPT] from OID3 to OID
        =>
        < OID : Worker | > .

    ***Transporters discard worker tasks.
    rl [rcvWrongTransporterTask] :
        < OID : Transporter | >
        msg [OID2, WT] from OID3 to OID
        =>
        < OID : Transporter | > .
        
    ***When robot is finished with all negotiations, check if it needs to wait for someone else.
    rl [finishNegotiating] :
        < OID : Robot | state : negotiating, negotiations : none, waitingStatus : WI >
        =>
        if WI == noWaitingInformation
        then
            < OID : Robot | state : idle >
        else
            < OID : Robot | state : waiting >
        fi .

    rl [rcvObstacleRemovedMsg] : 
        < OID : Robot | obstructionPoints : LL >
        msg removed (X,Y) from OID2 to OID
        =>
        < OID : Robot | obstructionPoints : remove(LL, (X,Y)) > .

    crl [rcvTaskMsgBusy] :
        < OID : Robot | >
        msg TID from OID2 to OID
        =>
        < OID : Robot | >
        if mustRejectTask(< OID : Robot  | >) .

    ***can only accept tasks of correct type
    crl [rcvTaskMsgFree] :
        < OID : Robot | location : (X,Y), obstructionPoints : LL >
        < OID2 : Map | allIntersections : CONF >
        msg [OID3, TT] from OID3 to OID
        =>
        < OID : Robot | >
        < OID2 : Map | >
        dly(msg bid cost(calculatePathLength(< OID : Robot | >, [OID3, TT], < OID2 : Map | >)) on [OID3, TT] from OID to OID3, MSG-DELAY)
        if not mustRejectTask(< OID : Robot | >) and compatibleTaskType(< OID : Robot | >, TT) .

    --- crl [arriveAtFixLoc] :
    ---     < OID : Robot | location : (X,Y), remainingPath : (X,Y), state : STATE >
    ---     =>
    ---     < OID : Robot | remainingPath : nil >
    ---     if (STATE == removing) or (STATE == repairing) .

    rl [detectFunctioningRobot] :
        < OID : Robot | detected : {OID2 : Robot | FUNC ; I} REPS >
        < OID3 : Map | >
        =>
        safetyChecks(< OID : Robot | detected : REPS >, {OID2 : Robot | FUNC ; I}, < OID3 : Map | >)
        < OID3 : Map | > .

    rl [detectFailedRobot] :
        < OID : Robot | state : FUNC, location : (X,Y), remainingPath : LL, detected : {OID2 : Robot | INC ; (X2,Y2) ; I} REPS, obstructionPoints : LL2 >
        < OID2 : Robot | location : (X2,Y2) >
        < OID3 : Map | >
        CONF
        =>
        if canCompleteNow(< OID : Robot | >, [OID2, repairAt (X2,Y2)])
        then
            crashPrevention(< OID : Robot | state : moving,
                remainingPath : planPath(< OID : Robot | >, [OID2, repairAt (X2,Y2)], < OID3 : Map | >),
                detected : REPS, curTask : [OID2, repairAt (X2,Y2)], obstructionPoints : (X2,Y2) LL2 >, {OID2 : Robot | INC ; (X2,Y2) ; I})
            < OID2 : Robot | >
            < OID3 : Map | >
            CONF
        else
            if between((X2,Y2), (X,Y) LL) =/= nil
            then
                initiateAuction(< OID : Robot | state : planningPath, detected : REPS, obstructionPoints : (X2,Y2) LL2 >, [OID2, repairAt (X2,Y2)], CONF)
                < OID2 : Robot | >
                < OID3 : Map | >
                CONF
            else
                initiateAuction(< OID : Robot | detected : REPS, obstructionPoints : (X2, Y2) LL2 >, [OID2, repairAt (X2,Y2)], CONF)
                < OID2 : Robot | >
                < OID3 : Map | >
                CONF
            fi
        fi .
    
    rl [detectIgnore] :
        < OID : Robot | state : INC, detected : REPS >
        =>
        < OID : Robot | state : INC, detected : none > .

    rl [detectObstacle] : 
        < OID : Robot | state : FUNC, location : (X,Y), remainingPath : LL, detected : {OID2 : Obstacle | (X2,Y2)} REPS, obstructionPoints : LL2  > 
        < OID2 : Obstacle | location : (X2,Y2) >
        < OID3 : Map | > 
        CONF
        =>
        if canCompleteNow(< OID : Robot | >, [OID2, removeAt (X2,Y2)])
        then
            crashPrevention(< OID : Robot | state : moving,
                remainingPath : planPath(< OID : Robot | >, [OID2, removeAt (X2,Y2)], < OID3 : Map | > < OID2 : Obstacle | >),
                detected : REPS, curTask : [OID2, removeAt (X2,Y2)], obstructionPoints : (X2,Y2) LL2 >, {OID2 : Obstacle | (X2,Y2)})
            broadcastInRange(< OID : Robot | >, obstacleAt (X2,Y2), CONF)
            < OID2 : Obstacle | >
            < OID3 : Map | >
            CONF
        else
            if between((X2,Y2), (X,Y) LL) =/= nil
            then
                initiateAuction(< OID : Robot | state : planningPath, speed : 0, detected : REPS, obstructionPoints : (X2,Y2) LL2 >, [OID2, removeAt (X2,Y2)], CONF)
                < OID2 : Obstacle | >
                < OID3 : Map | >
                CONF
            else
                initiateAuction(< OID : Robot | detected : REPS, obstructionPoints : (X2, Y2) LL2 >, [OID2, removeAt (X2,Y2)], CONF)
                < OID2 : Obstacle | >
                < OID3 : Map | >
                CONF
            fi
        fi .

    crl [startObstacleRemoval] :
        < OID : Robot | location : (X,Y), curTask : [OID2, removeAt (X2,Y2)], workState : noWork >
        < OID2 : Obstacle | location : (X2,Y2) >
        =>
        < OID : Robot | state : removing, remainingPath : nil, speed : 0, workState : [OID2, (removeAt (X2,Y2)), REMOVAL-TIME] >
        < OID2 : Obstacle | > 
        if canCompleteNow(< OID : Robot | >, [OID2, removeAt (X2,Y2)]) and distance((X,Y), (X2,Y2)) <= WORK-RANGE .

    rl [finishObstacleRemoval] :
        < OID : Robot | location : (X,Y), curTask : [OID2, removeAt (X2,Y2)], workState : [OID2, (removeAt (X2,Y2))] >
        < OID2 : Obstacle | location : (X2,Y2) >
        CONF
        =>
        < OID : Robot | speed : 0, state : idle, curTask : noTask, workState : noWork >
        broadcastInRange(< OID : Robot | >, removed (X2,Y2), CONF)
        CONF .

    crl [startRobotRepair] :
        < OID : Robot | location : (X,Y), curTask : [OID2, repairAt (X2,Y2)], workState : noWork >
        < OID2 : Robot | location : (X2,Y2), state : crashed > 
        =>
        < OID : Robot | state : repairing, workState : [OID2, (repairAt (X2,Y2)), REPAIR-TIME] >
        < OID2 : Robot | >
        if canCompleteNow(< OID : Robot | >, [OID2, repairAt (X2,Y2)]) and distance((X,Y), (X2,Y2)) <= WORK-RANGE .

    rl [finishRobotRepair] :
        < OID : Robot | location : (X,Y), curTask : [OID2, repairAt (X2,Y2)], workState : [OID2, (repairAt (X2,Y2))] >
        < OID2 : Robot | state : crashed, location : (X2,Y2) >
        =>
        < OID : Robot | speed : 0, state : idle, curTask : noTask, workState : noWork > 
        < OID2 : Robot | state : idle > .

    crl [startResupply] :
        < OID : Robot | state : FUNC, location : (X,Y), curTask : TID >
        < OID2 : ResupplyStation | location : (X,Y) >
        =>
        < OID : Robot | speed : 0, state : resupplying, workState : [OID2, resupplyTask, RESUPPLY-TIME] > 
        < OID2 : ResupplyStation | >
        if needsResupply(< OID : Robot | >, TID) and FUNC =/= resupplying .

    rl [finishResupply] :
        < OID : Robot | location : (X,Y), state : resupplying, curTask : [OID2, TT], workState : [OID3, resupplyTask, 0] >
        < OID4 : Map | allIntersections : < OID3 : ResupplyStation | location : (X,Y) > CONF >
        =>
        finishedResupply(< OID : Robot | workState : noWork >, TT)
        < OID4 : Map | > .

    rl [startUnloading] : 
        < OID : Transporter | state : FUNC, location : (X,Y), curCargo : produce, cargoLevel : full, workState : noWork >
        < OID2 : Map | allIntersections : < OID3 : CollectionStation | location : (X,Y) > CONF >
        =>
        < OID : Transporter | speed : 0, state : unloading,  workState : [OID2, unloadTask, UNLOAD-TIME] >
        < OID2 : Map | allIntersections : < OID3 : CollectionStation | location : (X,Y) > CONF > .
    
    rl [finishUnloading] :
        < OID : Transporter | state : unloading, curCargo : produce, location : (X,Y), cargoLevel : full, workState : [OID2, unloadTask, 0] >
        < OID2 : Map | allIntersections : < OID3 : CollectionStation | location : (X,Y), collections : N > CONF >
        =>
        < OID : Transporter | state : idle, cargoLevel : empty, workState : noWork >
        < OID2 : Map | allIntersections : < OID3 : CollectionStation | location : (X,Y), collections : N + 1 > CONF > .

    rl [startGrowingLocTask] :
        < OID : Robot | state : FUNC, location : (X,Y), curTask : [OID2, TT], remainingPath : nil, workState : noWork >
        < OID2 : Field | growingArea : A, location : (X,Y), reserved : false >
        =>
        if canCompleteNow(< OID : Robot | >, [OID2, TT])
        then
            < OID : Robot | remainingPath : (X,Y) coverArea((X,Y), A), workState : [OID2, TT], speed : 1, state : moving >
            < OID2 : Field | reserved : true >
        else
            < OID : Robot | speed : 0, state : planningPath >
            < OID2 : Field | >
        fi .

    rl [finishWorkerFieldTask] :
        < OID : Worker | state : FUNC, location : (X,Y), remainingPath : nil, workState : [OID2, WT], cargoLevel : full >
        < OID2 : Field | location : (X,Y), reserved : true >
        =>
        < OID : Worker | cargoLevel : empty, curTask : noTask, workState : noWork >
        taskComplete(< OID2 : Field | >, [OID2, WT]) . 

    rl [finishTransporterFieldTask] :
        < OID : Transporter | state : FUNC, location : (X,Y), curTask : [OID2, harvestTask], remainingPath : nil, workState : [OID2, TPT], cargoLevel : empty >
        < OID2 : Field | location : (X,Y), reserved : true >
        < OID3 : Map | allIntersections : < OID4 : CollectionStation | AS > CONF >
        =>
        < OID : Transporter | state : planningPath, curCargo : produce, cargoLevel : full, curTask : [OID4, unloadTask], workState : noWork >
        < OID3 : Map | >
        taskComplete(< OID2 : Field | >, [OID2, TPT]) .
endom